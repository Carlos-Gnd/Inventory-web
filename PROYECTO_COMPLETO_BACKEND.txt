REPORTE INTEGRAL - SMART INVENTORY
Fecha: 18/12/2025, 10:26:12 p.Â m.
================================================================================
ğŸŒ³ ESTRUCTURA DEL PROYECTO
================================================================================
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .~lock.PROYECTO_COMPLETO_V2.txt#
â”œâ”€â”€ Backend
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”‚   â””â”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ controllers
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ middleware
â”‚   â”‚   â”‚   â””â”€â”€ auth.middleware.ts
â”‚   â”‚   â”œâ”€â”€ models
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ repositories
â”‚   â”‚   â”‚   â”œâ”€â”€ categoria.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ descuento.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ historialSesion.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notificacion.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producto.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ usuario.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ venta.repository.ts
â”‚   â”‚   â”œâ”€â”€ routes
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ categoria.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ descuento.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ historialSesion.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notificacion.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ perfil.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producto.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reporte.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ usuario.routes.ts
â”‚   â”‚   â”‚   â””â”€â”€ venta.routes.ts
â”‚   â”‚   â”œâ”€â”€ services
â”‚   â”‚   â”‚   â”œâ”€â”€ emailService.ts
â”‚   â”‚   â”‚   â””â”€â”€ ticketService.ts
â”‚   â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”‚   â””â”€â”€ userAgent.ts
â”‚   â”‚   â””â”€â”€ workers
â”‚   â”‚       â””â”€â”€ emailWorker.ts
â”‚   â””â”€â”€ tsconfig.json
â”œâ”€â”€ db_scripts
â”‚   â”œâ”€â”€ 01_Schema_Principal.sql
â”‚   â”œâ”€â”€ 02_migration_barcode.sql
â”‚   â”œâ”€â”€ 03_migration_notificaciones.sql
â”‚   â”œâ”€â”€ 04_migration_perfil.sql
â”‚   â”œâ”€â”€ 05_update_triggers.sql
â”‚   â””â”€â”€ 06_migration_descuentos.sql
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ frontend
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ postcss.config.js
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”‚   â”œâ”€â”€ common
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Avatar.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Badge.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BarcodeDisplay.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Modal.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NotificationBell.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SearchBar.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Table.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ThemeToggle.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ features
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ descuentos
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ DescuentosWidget.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ notificaciones
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NotificacionesWidget.tsx
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ NotificacionFiltros.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ perfil
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MisSesiones.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ usuarios
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ModalEditarUsuario.tsx
â”‚   â”‚   â”‚   â””â”€â”€ layout
â”‚   â”‚   â”‚       â”œâ”€â”€ Layout.tsx
â”‚   â”‚   â”‚       â”œâ”€â”€ Navbar.tsx
â”‚   â”‚   â”‚       â””â”€â”€ Sidebar.tsx
â”‚   â”‚   â”œâ”€â”€ contexts
â”‚   â”‚   â”‚   â””â”€â”€ ThemeContext.tsx
â”‚   â”‚   â”œâ”€â”€ hooks
â”‚   â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useBarcodeScanner.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useDebounce.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useNotificaciones.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ usePagination.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useProductos.ts
â”‚   â”‚   â”‚   â””â”€â”€ useVentas.ts
â”‚   â”‚   â”œâ”€â”€ index.css
â”‚   â”‚   â”œâ”€â”€ main.tsx
â”‚   â”‚   â”œâ”€â”€ pages
â”‚   â”‚   â”‚   â”œâ”€â”€ Categorias.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Descuentos.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ HistorialSesiones.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MiPerfil.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Notificaciones.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Productos.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ RegistrarVentas.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Reportes.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Usuarios.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Ventas.tsx
â”‚   â”‚   â”‚   â””â”€â”€ VentasPropias.tsx
â”‚   â”‚   â”œâ”€â”€ services
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ authService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ categoriaService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ descuentoService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ historialSesionService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notificacionService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ perfilService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ productoService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reporteService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ usuarioService.ts
â”‚   â”‚   â”‚   â””â”€â”€ ventaService.ts
â”‚   â”‚   â”œâ”€â”€ store
â”‚   â”‚   â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ cartStore.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ notificacionStore.ts
â”‚   â”‚   â”‚   â””â”€â”€ uiStore.ts
â”‚   â”‚   â”œâ”€â”€ types
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”‚   â”œâ”€â”€ constants.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”‚   â””â”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ vite-env.d.ts
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ tsconfig.node.json
â”‚   â””â”€â”€ vite.config.ts
â”œâ”€â”€ Inventory-web
â”‚   â”œâ”€â”€ .gitattributes
â”‚   â””â”€â”€ LICENSE
â”œâ”€â”€ package.json
â”œâ”€â”€ PROYECTO_COMPLETO_V2.txt
â””â”€â”€ README.md


================================================================================
ğŸ“„ ARCHIVO RAÃZ: docker-compose.yml
================================================================================
# ./docker-compose.yml
services:
  # Base de Datos MariaDB
  mariadb:
    image: mariadb:11.2
    container_name: smart-inventory-db
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: admin123
      MYSQL_DATABASE: Smart_Inventory
      MYSQL_USER: smartuser
      MYSQL_PASSWORD: smart123
      MYSQL_CHARSET: utf8mb4
      MYSQL_COLLATION: utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mariadb_data:/var/lib/mysql
      - ./db_scripts:/docker-entrypoint-initdb.d
    networks:
      - smart-inventory-network
    healthcheck:
      test: ["CMD", "healthcheck.sh", "--connect", "--innodb_initialized"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: smart-inventory-backend
    restart: unless-stopped
    ports:
      - "3000:3000"
    
    # Carga todas las variables desde el archivo .env
    env_file:
      - ./backend/.env
    
    # Sobreescribimos solo lo necesario para producciÃ³n
    environment:
      NODE_ENV: production
      # Nota: DB_HOST, EMAIL_USER, etc., ya se leen automÃ¡ticamente del .env
      
    depends_on:
      mariadb:
        condition: service_healthy
    networks:
      - smart-inventory-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 60s

  # Frontend React
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: smart-inventory-frontend
    restart: unless-stopped
    ports:
      - "5173:5173"
    environment:
      VITE_API_URL: http://localhost:3000/api
    depends_on:
      backend:
        condition: service_started
    networks:
      - smart-inventory-network

volumes:
  mariadb_data:
    driver: local

networks:
  smart-inventory-network:
    driver: bridge

================================================================================
ğŸ“„ ARCHIVO RAÃZ: .gitignore
================================================================================
# .gitignore

# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Production builds
dist/
build/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# TypeScript
*.tsbuildinfo

# Backup files
*.sql.backup
backup.sql

# OS files
Thumbs.db

# --- FALTANTES IMPORTANTES ---

# Datos de la Base de Datos (Docker Volumes)
# Si en tu docker-compose mapeaste un volumen local, Â¡no lo subas!
mysql_data/
mysql_db/
data/
.db/

# Archivos subidos por usuarios (ImÃ¡genes de productos, etc.)
# Solo queremos el cÃ³digo, no las fotos de prueba de tu PC
uploads/
public/uploads/
tmp/

# Archivos de sistema operativo (Mac/Windows extra)
.DS_Store
Thumbs.db

# --- Utilidades Locales ---
exportar_proyecto.js

# --- Reportes de CÃ³digo (Â¡SENSITIVO!) ---
PROYECTO_COMPLETO.txt
PROYECTO_COMPLETO_V2.txt

================================================================================
ğŸ“„ ARCHIVO RAÃZ: README.md
================================================================================
# ğŸš€ Smart Inventory - Sistema de GestiÃ³n Web

Sistema moderno de inventario y ventas migrado de C# WinForms a stack web moderno.

---

## ğŸ“‹ Stack TecnolÃ³gico

### **Backend**
- Node.js 18+
- Express.js
- TypeScript
- MariaDB 11.2
- JWT Authentication

### **Frontend**
- React 18
- TypeScript
- Tailwind CSS
- Zustand (State Management)
- Vite (Build Tool)
- React Router
- Lucide Icons

---

## ğŸ› ï¸ InstalaciÃ³n

### **Requisitos Previos**
- Node.js 18+ instalado
- Docker y Docker Compose (Opcional pero recomendado)
- MariaDB 11+ (si no usas Docker)

---

## ğŸ³ OpciÃ³n 1: InstalaciÃ³n con Docker (Recomendado)

### **Paso 1: Clonar el repositorio**
```bash
git clone <tu-repo>
cd smart-inventory-web
```

### **Paso 2: Configurar variables de entorno**

**Backend (.env):**
```bash
cd backend
cp .env.example .env
# Editar .env si es necesario
```

**Frontend (.env):**
```bash
cd frontend
cp .env.example .env
# Verificar que VITE_API_URL=http://localhost:3000/api
```

### **Paso 3: Levantar todos los servicios**
```bash
# Desde la raÃ­z del proyecto
docker-compose up -d --build
```

### **Paso 4: Verificar que todo estÃ© funcionando**
```bash
# Ver logs
docker-compose logs -f

# Verificar servicios
docker-compose ps
```

**URLs de acceso:**
- Frontend: http://localhost:5173
- Backend API: http://localhost:3000/api
- Health Check: http://localhost:3000/api/health

### **Credenciales por defecto:**
- **Admin:** `admin` / `admin123`
- **Cajero:** `cajero` / `cajero123`

---

## ğŸ’» OpciÃ³n 2: InstalaciÃ³n Manual (Sin Docker)

### **Paso 1: Instalar MariaDB**

**Crear la base de datos:**
```sql
CREATE DATABASE Smart_Inventory CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'smartuser'@'localhost' IDENTIFIED BY 'smart123';
GRANT ALL PRIVILEGES ON Smart_Inventory.* TO 'smartuser'@'localhost';
FLUSH PRIVILEGES;
```

**Ejecutar el script SQL:**
```bash
mysql -u smartuser -p Smart_Inventory < Smart_Inventory_Script.sql
```

### **Paso 2: Backend**

```bash
cd backend

# Instalar dependencias
npm install

# Configurar .env
cp .env.example .env
# Editar .env con tu configuraciÃ³n de base de datos

# Modo desarrollo
npm run dev

# O compilar y ejecutar en producciÃ³n
npm run build
npm start
```

### **Paso 3: Frontend**

```bash
cd frontend

# Instalar dependencias
npm install

# Configurar .env
cp .env.example .env

# Modo desarrollo
npm run dev

# O compilar para producciÃ³n
npm run build
npm run preview
```

---

## ğŸ“¦ Estructura del Proyecto

```
smart-inventory-web/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â””â”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”œâ”€â”€ usuario.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ categoria.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producto.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ venta.repository.ts
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ usuario.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ categoria.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producto.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ venta.routes.ts
â”‚   â”‚   â”‚   â””â”€â”€ reporte.routes.ts
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â””â”€â”€ auth.middleware.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ auth.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ .env.example
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”‚   â””â”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â”œâ”€â”€ main.tsx
â”‚   â”‚   â””â”€â”€ vite-env.d.ts
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â”œâ”€â”€ postcss.config.js
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ Smart_Inventory_Script.sql
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

---

## ğŸ”§ Comandos Ãštiles de Docker

```bash
# Iniciar servicios
docker-compose up -d

# Ver logs en tiempo real
docker-compose logs -f

# Ver logs de un servicio especÃ­fico
docker-compose logs -f backend
docker-compose logs -f frontend
docker-compose logs -f mariadb

# Detener servicios
docker-compose down

# Detener y eliminar volÃºmenes (âš ï¸ Borra la BD)
docker-compose down -v

# Reconstruir imÃ¡genes
docker-compose build

# Reiniciar un servicio especÃ­fico
docker-compose restart backend

# Ver estado de los servicios
docker-compose ps

# Ejecutar comandos dentro de un contenedor
docker-compose exec backend sh
docker-compose exec mariadb mysql -u root -p

# Ver uso de recursos
docker stats
```

---

## ğŸ—„ï¸ Comandos de Base de Datos

### **Acceder a MariaDB en Docker:**
```bash
docker-compose exec mariadb mysql -u root -p
# Password: admin123
```

### **Backup de la base de datos:**
```bash
docker-compose exec mariadb mysqldump -u root -padmin123 Smart_Inventory > backup.sql
```

### **Restaurar backup:**
```bash
docker-compose exec -T mariadb mysql -u root -padmin123 Smart_Inventory < backup.sql
```

---

## ğŸ› Troubleshooting

### **Error: Puerto 3000 o 5173 ya en uso**
```bash
# Encontrar el proceso usando el puerto
lsof -ti:3000
lsof -ti:5173

# Matar el proceso
kill -9 <PID>

# O cambiar el puerto en docker-compose.yml o .env
```

### **Error: No se puede conectar a la base de datos**
```bash
# Verificar que MariaDB estÃ© corriendo
docker-compose ps

# Ver logs de MariaDB
docker-compose logs mariadb

# Verificar conexiÃ³n
docker-compose exec mariadb mysql -u smartuser -psmart123 -e "SHOW DATABASES;"
```

### **Error: CORS en el frontend**
Verificar que en `backend/.env`:
```bash
CORS_ORIGIN=http://localhost:5173
```

### **Error: Frontend no puede importar `import.meta.env`**
AsegÃºrate de que existe `frontend/src/vite-env.d.ts` con:
```typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

---

## ğŸ“ Funcionalidades

### **MÃ³dulo Administrador:**
- âœ… GestiÃ³n de Usuarios
- âœ… GestiÃ³n de CategorÃ­as
- âœ… GestiÃ³n de Productos
- âœ… VisualizaciÃ³n de todas las Ventas
- âœ… GeneraciÃ³n de Reportes (Excel/PDF)
- âœ… Dashboard con estadÃ­sticas

### **MÃ³dulo Cajero:**
- âœ… Registrar Ventas
- âœ… Ver Ventas Propias
- âœ… Generar Reportes Personales
- âœ… Dashboard personal

### **CaracterÃ­sticas Generales:**
- âœ… AutenticaciÃ³n JWT
- âœ… Control de roles (Admin/Cajero)
- âœ… BÃºsqueda y filtros
- âœ… ExportaciÃ³n Excel/PDF
- âœ… Alertas de stock bajo
- âœ… Responsive design
- âœ… Notificaciones toast

---

## ğŸ” Seguridad

- ContraseÃ±as hasheadas con SHA256
- AutenticaciÃ³n basada en JWT
- Middleware de autorizaciÃ³n
- ValidaciÃ³n de datos en backend
- CORS configurado

---

## ğŸš€ Despliegue en ProducciÃ³n

### **Variables de entorno importantes:**

**Backend:**
```bash
NODE_ENV=production
JWT_SECRET=<generar-uno-seguro-aqui>
DB_HOST=<tu-host-de-bd>
DB_PASSWORD=<password-seguro>
CORS_ORIGIN=https://tu-dominio.com
```

**Frontend:**
```bash
VITE_API_URL=https://api.tu-dominio.com/api
```

### **Build de producciÃ³n:**
```bash
# Backend
cd backend
npm run build

# Frontend
cd frontend
npm run build
# Los archivos estarÃ¡n en frontend/dist/
```

---

## ğŸ“§ Soporte

Para preguntas o problemas, abre un issue en el repositorio.

---

## ğŸ“„ Licencia

Este proyecto estÃ¡ bajo la Licencia MIT.

---

## ğŸ‰ Â¡Listo para usar!

Ahora tienes un sistema completo de inventario moderno. Â¡Disfruta! ğŸš€

================================================================================
ğŸ“‚ RUTA: backend\.env
================================================================================
# Server Configuration
NODE_ENV=development
PORT=3000

# Database Configuration (Docker)
DB_HOST=mariadb
DB_PORT=3306
DB_USER=smartuser
DB_PASSWORD=smart123
DB_NAME=Smart_Inventory

# JWT Configuration
JWT_SECRET=tu_super_secreto_jwt_2025_cambiar_en_produccion
JWT_EXPIRES_IN=24h

# CORS Configuration
CORS_ORIGIN=http://localhost:5173

# Logs
LOG_LEVEL=info

# Email Configuration - Gmail SMTP
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_SECURE=false
EMAIL_USER="carlosgnd23@gmail.com"
EMAIL_PASSWORD="sbevxecbwkrlojda"
EMAIL_FROM="Smart Inventory <carlosgnd23@gmail.com>"
EMAIL_ADMIN="carlosg23092004@gmail.com"

# Habilitar/deshabilitar emails
EMAIL_ENABLED=true

================================================================================
ğŸ“‚ RUTA: backend\Dockerfile
================================================================================
# backend/Dockerfile
FROM node:18-alpine AS builder

# instalar curl y que el healthcheck funcione
RUN apk add --no-cache curl

WORKDIR /app

# Copiar package files
COPY package*.json ./
COPY tsconfig.json ./

# Instalar dependencias
RUN npm ci

# Copiar cÃ³digo fuente
COPY src ./src

# Compilar TypeScript
RUN npm run build

# Etapa de producciÃ³n
FROM node:18-alpine

WORKDIR /app

# Copiar package files
COPY package*.json ./

# Instalar solo dependencias de producciÃ³n
RUN npm ci --only=production

# Copiar cÃ³digo compilado desde builder
COPY --from=builder /app/dist ./dist

# Crear usuario no-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

USER nodejs

# Exponer puerto
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# Comando de inicio
CMD ["node", "dist/index.js"]

================================================================================
ğŸ“‚ RUTA: backend\package.json
================================================================================
{
  "name": "smart-inventory-backend",
  "version": "1.0.0",
  "description": "Backend API para Smart Inventory",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "lint": "eslint . --ext .ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "inventory",
    "api",
    "typescript"
  ],
  "author": "Smart Inventory Team",
  "license": "MIT",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "exceljs": "^4.4.0",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.6.5",
    "nodemailer": "^7.0.11",
    "pdfkit": "^0.13.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20.10.5",
    "@types/nodemailer": "^6.4.21",
    "@types/pdfkit": "^0.13.4",
    "@typescript-eslint/eslint-plugin": "^6.15.0",
    "@typescript-eslint/parser": "^6.15.0",
    "eslint": "^8.56.0",
    "nodemon": "^3.0.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}


================================================================================
ğŸ“‚ RUTA: backend\src\config\database.ts
================================================================================
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';

dotenv.config();

// ConfiguraciÃ³n de conexiÃ³n a MariaDB
export const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '3306'),
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'admin123',
  database: process.env.DB_NAME || 'Smart_Inventory',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  enableKeepAlive: true,
  keepAliveInitialDelay: 0
});

// FunciÃ³n para verificar la conexiÃ³n
export async function testConnection(): Promise<void> {
  try {
    const connection = await pool.getConnection();
    console.log('âœ… ConexiÃ³n exitosa a MariaDB');
    console.log(`ğŸ“¦ Base de datos: ${process.env.DB_NAME || 'Smart_Inventory'}`);
    connection.release();
  } catch (error) {
    console.error('âŒ Error al conectar con MariaDB:', error);
    throw error;
  }
}

// FunciÃ³n para ejecutar el script de inicializaciÃ³n (si es necesario)
export async function initializeDatabase(): Promise<void> {
  try {
    const connection = await pool.getConnection();
    
    // Verificar si las tablas existen
    const [tables] = await connection.query(
      "SHOW TABLES LIKE 'Usuarios'"
    );
    
    if (Array.isArray(tables) && tables.length === 0) {
      console.log('âš ï¸  Base de datos vacÃ­a. Ejecutando script de inicializaciÃ³n...');
      // AquÃ­ podrÃ­as ejecutar el script SQL de inicializaciÃ³n
      // Por ahora, solo advertimos
      console.log('âš ï¸  Por favor, ejecuta el script Smart_Inventory_Script.sql manualmente');
    } else {
      console.log('âœ… Tablas de base de datos encontradas');
    }
    
    connection.release();
  } catch (error) {
    console.error('Error al inicializar base de datos:', error);
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\index.ts
================================================================================
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { testConnection } from './config/database';

// Routes
import authRoutes from './routes/auth.routes';
import usuarioRoutes from './routes/usuario.routes';
import categoriaRoutes from './routes/categoria.routes';
import productoRoutes from './routes/producto.routes';
import ventaRoutes from './routes/venta.routes';
import reporteRoutes from './routes/reporte.routes';
import historialSesionRoutes from './routes/historialSesion.routes';
import perfilRoutes from './routes/perfil.routes';
import notificacionRoutes from './routes/notificacion.routes';
import { emailWorker } from './workers/emailWorker';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:5173'
}));
app.use(express.json({ limit: '10mb' })); // Aumentar lÃ­mite para imÃ¡genes
app.use(express.urlencoded({ extended: true, limit: '10mb' }));


// ENDPOINT DE SALUD
app.get('/api/health', (_req, res) => {
  res.status(200).json({
    status: 'ok',
    message: 'Smart Inventory API funcionando correctamente',
    timestamp: new Date().toISOString()
  });
});

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/usuarios', usuarioRoutes);
app.use('/api/categorias', categoriaRoutes);
app.use('/api/productos', productoRoutes);
app.use('/api/ventas', ventaRoutes);
app.use('/api/reportes', reporteRoutes);
app.use('/api/historial-sesiones', historialSesionRoutes);
app.use('/api/perfil', perfilRoutes);
app.use('/api/notificaciones', notificacionRoutes);

// Error handling
app.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Algo saliÃ³ mal en el servidor' });
});

// Start server
const startServer = async () => {
  try {
    await testConnection();
    app.listen(PORT, () => {
      console.log(`ğŸš€ Servidor corriendo en puerto ${PORT}`);
      console.log(`ğŸ“¡ API disponible en http://localhost:${PORT}/api`);

      // Iniciar email worker
      emailWorker.start();
    });
  } catch (error) {
    console.error('âŒ Error al iniciar el servidor:', error);
    process.exit(1);
  }
};

// Manejar seÃ±ales de cierre
process.on('SIGTERM', () => {
  console.log('âš ï¸ SIGTERM recibido, cerrando worker...');
  emailWorker.stop();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('âš ï¸ SIGINT recibido, cerrando worker...');
  emailWorker.stop();
  process.exit(0);
});

startServer();

================================================================================
ğŸ“‚ RUTA: backend\src\middleware\auth.middleware.ts
================================================================================
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/auth';

export interface AuthRequest extends Request {
  user?: {
    userId: number;
    username: string;
    role: number;
  };
}

export const authMiddleware = (req: AuthRequest, res: Response, next: NextFunction): void => {
  try {
    let token = req.headers.authorization?.replace('Bearer ', '');
    if (!token && req.query.token) {
      token = req.query.token as string;
    }

    if (!token) {
      res.status(401).json({ error: 'No se proporcionÃ³ token de autenticaciÃ³n' });
      return;
    }

    const decoded = verifyToken(token);
    req.user = decoded;
    next();;
  } catch (error) {
    res.status(401).json({ error: 'Token invÃ¡lido o expirado' });
    return;
  }
};

export const isAdmin = (req: AuthRequest, res: Response, next: NextFunction): void => {
  if (req.user?.role !== 1) {
    res.status(403).json({ error: 'Acceso denegado. Se requieren permisos de administrador' });
    return;
  }
  next();
};

================================================================================
ğŸ“‚ RUTA: backend\src\models\index.ts
================================================================================
// Backend/src/models/index.ts

export interface Rol {
  IdRol: number;
  RolNombre: string;
}

export interface Usuario {
  IdUsuario?: number;
  Nombre: string;
  Apellido: string;
  UsuarioNombre: string;
  ClaveHash?: string;
  IdRol: number;
  Activo: boolean;
  FechaRegistro?: Date;
  Rol?: Rol;
  
  // CAMPOS PARA PERFIL
  FotoPerfil?: string;      // Base64 o URL
  Telefono?: string;
  Email?: string;
  Direccion?: string;
  FechaNacimiento?: Date;
}

export interface Categoria {
  IdCategoria?: number;
  Nombre: string;
  Descripcion?: string;
}

export interface Producto {
  IdProducto?: number;
  Nombre: string;
  CodigoBarras?: string;
  IdCategoria: number;
  Precio: number;
  Stock: number;
  Estado: boolean;
  Descripcion?: string;
  StockMinimo: number;
  FechaRegistro?: Date;
  EsProductoFinal: boolean;
  Categoria?: Categoria;
}

export interface Venta {
  IdVenta?: number;
  Fecha?: Date;
  IdUsuario: number;
  Subtotal?: number;
  Descuento?: number;
  Total: number;
  MetodoPago: string;
  Comentario?: string;
  Estado: boolean;
  FechaVenta?: Date;
  CantidadTotalProductos?: number;
  Usuario?: Usuario;
  DetallesVenta?: DetalleVenta[];
  // GUARDAR EL HISTORIAL DEL CUPÃ“N USADO
  DescuentosAplicados?: Array<{
    IdDescuento: number;
    MontoDescuento: number;
    TipoDescuento: string;
    DescripcionDescuento: string;
  }>;
}

export interface DetalleVenta {
  IdDetalle?: number;
  IdVenta?: number;
  IdProducto: number;
  Cantidad: number;
  PrecioUnitario: number;
  Subtotal: number;
  Producto?: Producto;
}

export interface Reporte {
  IdReporte?: number;
  IdUsuario: number;
  TipoReporte: string;
  FechaGeneracion?: Date;
  RutaArchivo: string;
  Usuario?: Usuario;
}

export interface LoginRequest {
  usuario: string;
  clave: string;
}

export interface LoginResponse {
  message: string;
  usuario: Omit<Usuario, 'ClaveHash'>;
  token: string;
}

export interface HistorialSesion {
  IdSesion?: number;
  IdUsuario: number;
  FechaHora?: Date;
  DireccionIP: string;
  Navegador: string;
  Dispositivo: string;
  SistemaOperativo: string;
  Exitoso: boolean;
  MotivoFallo?: string;
  Usuario?: Usuario;
}

// Request para actualizar perfil
export interface ActualizarPerfilRequest {
  Nombre?: string;
  Apellido?: string;
  FotoPerfil?: string;
  Telefono?: string;
  Email?: string;
  Direccion?: string;
  FechaNacimiento?: string;
}

// Tipos adicionales para el frontend
export interface PerfilUsuario extends Omit<Usuario, 'ClaveHash'> {}

export interface ActualizarFotoRequest {
  FotoPerfil: string;
}

// ==================== NOTIFICACIONES ====================
export type TipoNotificacion = 'stock_bajo' | 'stock_critico' | 'venta' | 'sistema' | 'alerta';
export type PrioridadNotificacion = 'baja' | 'media' | 'alta' | 'critica';

export interface Notificacion {
  IdNotificacion?: number;
  Tipo: TipoNotificacion;
  Titulo: string;
  Mensaje: string;
  IdProducto?: number;
  IdUsuario?: number;
  Prioridad: PrioridadNotificacion;
  Leida: boolean;
  FechaCreacion?: Date;
  FechaLeida?: Date;
  Icono?: string;
  Color?: string;
  Metadata?: any;
  
  // Relaciones
  Producto?: {
    Nombre: string;
    Stock: number;
    StockMinimo: number;
  };
}

export interface EstadisticasNotificaciones {
  TotalNotificaciones: number;
  NoLeidas: number;
  Criticas: number;
  Altas: number;
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\categoria.repository.ts
================================================================================
import { pool } from '../config/database';
import { Categoria } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export class CategoriaRepository {
  async listar(): Promise<Categoria[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      'SELECT IdCategoria, Nombre, Descripcion FROM Categorias'
    );
    
    return rows.map(row => ({
      IdCategoria: row.IdCategoria,
      Nombre: row.Nombre,
      Descripcion: row.Descripcion
    }));
  }

  async registrar(categoria: Categoria): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(
      `INSERT INTO Categorias (Nombre, Descripcion) 
       VALUES (?, ?)`,
      [categoria.Nombre, categoria.Descripcion]
    );
    return result.insertId;
  }

  async editar(categoria: Categoria): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Categorias 
       SET Nombre = ?, Descripcion = ? 
       WHERE IdCategoria = ?`,
      [categoria.Nombre, categoria.Descripcion, categoria.IdCategoria]
    );
    return result.affectedRows > 0;
  }

  async eliminar(idCategoria: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'DELETE FROM Categorias WHERE IdCategoria = ?',
      [idCategoria]
    );
    return result.affectedRows > 0;
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\descuento.repository.ts
================================================================================
// Backend/src/repositories/descuento.repository.ts

import { pool } from '../config/database';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export interface Descuento {
  IdDescuento?: number;
  Nombre: string;
  Descripcion?: string;
  Tipo: 'porcentaje' | 'monto_fijo' | '2x1' | '3x2' | 'combo';
  Valor?: number;
  FechaInicio: string;
  FechaFin: string;
  Activo: boolean;
  MontoMinimo: number;
  IdCategoriaAplica?: number;
  IdProductoAplica?: number;
  CodigoCupon?: string;
  UsosMaximos?: number;
  UsosActuales?: number;
  ProductosCombo?: any;
  CreadoPor: number;
  FechaCreacion?: string;
  CategoriaNombre?: string;
  ProductoNombre?: string;
  DiasRestantes?: number;
  PorcentajeUso?: string;
}

export interface VentaDescuento {
  IdVentaDescuento?: number;
  IdVenta: number;
  IdDescuento: number;
  MontoDescuento: number;
  TipoDescuento: string;
  DescripcionDescuento?: string;
}

// NUEVO: Interfaz para items del carrito
export interface ItemCarrito {
  IdProducto: number;
  Cantidad: number;
  PrecioUnitario: number;
  Subtotal: number;
  IdCategoria?: number;
}

// NUEVO: Resultado de aplicar descuentos
export interface ResultadoDescuentos {
  descuentosAplicados: DescuentoAplicado[];
  subtotal: number;
  totalDescuento: number;
  total: number;
}

export interface DescuentoAplicado {
  descuento: Descuento;
  montoDescuento: number;
  descripcion: string;
  itemsAfectados?: number[]; // IDs de productos afectados
}

export class DescuentoRepository {
  
  // ==================== CRUD BÃSICO ====================
  
  async listar(): Promise<Descuento[]> {
    const [rows] = await pool.query<RowDataPacket[]>(`
      SELECT 
        d.*,
        c.Nombre AS CategoriaNombre,
        p.Nombre AS ProductoNombre,
        DATEDIFF(d.FechaFin, NOW()) AS DiasRestantes,
        CASE 
          WHEN d.UsosMaximos IS NULL THEN 'Ilimitado'
          ELSE CONCAT(ROUND((d.UsosActuales / d.UsosMaximos) * 100, 1), '%')
        END AS PorcentajeUso
      FROM Descuentos d
      LEFT JOIN Categorias c ON d.IdCategoriaAplica = c.IdCategoria
      LEFT JOIN Productos p ON d.IdProductoAplica = p.IdProducto
      ORDER BY d.FechaCreacion DESC
    `);

    return rows.map(this.mapRowToDescuento);
  }

  async listarActivos(): Promise<Descuento[]> {
    const [rows] = await pool.query<RowDataPacket[]>(`
      SELECT * FROM vw_DescuentosActivos
      ORDER BY 
        CASE Tipo
          WHEN '2x1' THEN 1
          WHEN '3x2' THEN 2
          WHEN 'combo' THEN 3
          WHEN 'porcentaje' THEN 4
          WHEN 'monto_fijo' THEN 5
        END
    `);

    return rows.map(this.mapRowToDescuento);
  }

  async obtenerPorId(id: number): Promise<Descuento | null> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT 
        d.*,
        c.Nombre AS CategoriaNombre,
        p.Nombre AS ProductoNombre
      FROM Descuentos d
      LEFT JOIN Categorias c ON d.IdCategoriaAplica = c.IdCategoria
      LEFT JOIN Productos p ON d.IdProductoAplica = p.IdProducto
      WHERE d.IdDescuento = ?`,
      [id]
    );

    if (rows.length === 0) return null;
    return this.mapRowToDescuento(rows[0]);
  }

  async crear(descuento: Descuento): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(
      `INSERT INTO Descuentos (
        Nombre, Descripcion, Tipo, Valor,
        FechaInicio, FechaFin, Activo,
        MontoMinimo, IdCategoriaAplica, IdProductoAplica,
        CodigoCupon, UsosMaximos, ProductosCombo, CreadoPor
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        descuento.Nombre,
        descuento.Descripcion || null,
        descuento.Tipo,
        descuento.Valor || null,
        descuento.FechaInicio,
        descuento.FechaFin,
        descuento.Activo,
        descuento.MontoMinimo,
        descuento.IdCategoriaAplica || null,
        descuento.IdProductoAplica || null,
        descuento.CodigoCupon || null,
        descuento.UsosMaximos || null,
        descuento.ProductosCombo ? JSON.stringify(descuento.ProductosCombo) : null,
        descuento.CreadoPor
      ]
    );

    return result.insertId;
  }

  async actualizar(id: number, descuento: Partial<Descuento>): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Descuentos SET
        Nombre = ?,
        Descripcion = ?,
        Tipo = ?,
        Valor = ?,
        FechaInicio = ?,
        FechaFin = ?,
        Activo = ?,
        MontoMinimo = ?,
        IdCategoriaAplica = ?,
        IdProductoAplica = ?,
        CodigoCupon = ?,
        UsosMaximos = ?
      WHERE IdDescuento = ?`,
      [
        descuento.Nombre,
        descuento.Descripcion || null,
        descuento.Tipo,
        descuento.Valor || null,
        descuento.FechaInicio,
        descuento.FechaFin,
        descuento.Activo,
        descuento.MontoMinimo,
        descuento.IdCategoriaAplica || null,
        descuento.IdProductoAplica || null,
        descuento.CodigoCupon || null,
        descuento.UsosMaximos || null,
        id
      ]
    );

    return result.affectedRows > 0;
  }

  async eliminar(id: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'DELETE FROM Descuentos WHERE IdDescuento = ?',
      [id]
    );

    return result.affectedRows > 0;
  }

  async toggleActivo(id: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'UPDATE Descuentos SET Activo = NOT Activo WHERE IdDescuento = ?',
      [id]
    );

    return result.affectedRows > 0;
  }

  // ==================== VALIDACIÃ“N Y CÃLCULO ====================
  
  async validarCupon(codigo: string, montoCompra: number): Promise<{
    descuento: Descuento | null;
    valido: boolean;
    mensaje: string;
  }> {
    const [rows] = await pool.query<RowDataPacket[]>(
      'CALL sp_ValidarCupon(?, ?)',
      [codigo, montoCompra]
    );

    if (!rows || rows.length === 0 || !rows[0] || rows[0].length === 0) {
      return {
        descuento: null,
        valido: false,
        mensaje: 'CupÃ³n no encontrado'
      };
    }

    const row = rows[0][0];
    const estado = row.EstadoValidacion;

    if (estado !== 'VALIDO') {
      return {
        descuento: null,
        valido: false,
        mensaje: estado
      };
    }

    return {
      descuento: this.mapRowToDescuento(row),
      valido: true,
      mensaje: 'CupÃ³n vÃ¡lido'
    };
  }

  // NUEVO: Calcular descuento para un item especÃ­fico
  async calcularDescuentoItem(
    idDescuento: number,
    item: ItemCarrito
  ): Promise<number> {
    const descuento = await this.obtenerPorId(idDescuento);
    if (!descuento) return 0;

    let montoDescuento = 0;

    switch (descuento.Tipo) {
      case 'porcentaje':
        montoDescuento = (item.Subtotal * (descuento.Valor || 0)) / 100;
        break;

      case 'monto_fijo':
        montoDescuento = Math.min(descuento.Valor || 0, item.Subtotal);
        break;

      case '2x1':
        if (descuento.IdProductoAplica === item.IdProducto && item.Cantidad >= 2) {
          // Paga la mitad
          montoDescuento = item.Subtotal * 0.5;
        }
        break;

      case '3x2':
        if (descuento.IdProductoAplica === item.IdProducto && item.Cantidad >= 3) {
          // Por cada 3, 1 gratis
          const itemsGratis = Math.floor(item.Cantidad / 3);
          montoDescuento = itemsGratis * item.PrecioUnitario;
        }
        break;

      case 'combo':
        // Los combos se calculan a nivel de carrito completo
        montoDescuento = 0;
        break;
    }

    return Math.min(montoDescuento, item.Subtotal);
  }

  // NUEVO: Aplicar mÃºltiples descuentos a un carrito
  async aplicarDescuentos(
    items: ItemCarrito[],
    codigosCupones: string[] = [],
    idUsuario?: number
  ): Promise<ResultadoDescuentos> {
    const subtotal = items.reduce((sum, item) => sum + item.Subtotal, 0);
    const descuentosAplicados: DescuentoAplicado[] = [];

    // 1. Obtener descuentos automÃ¡ticos activos
    const descuentosAutomaticos = await this.obtenerDescuentosAplicables(items, subtotal);

    // 2. Validar cupones proporcionados
    for (const codigo of codigosCupones) {
      const validacion = await this.validarCupon(codigo, subtotal);
      if (validacion.valido && validacion.descuento) {
        descuentosAutomaticos.push(validacion.descuento);
      }
    }

    // 3. Ordenar por precedencia (especÃ­ficos primero, luego generales)
    const descuentosOrdenados = this.ordenarPorPrecedencia(descuentosAutomaticos);

    // 4. Aplicar descuentos en orden
    let totalDescuento = 0;

    for (const descuento of descuentosOrdenados) {
      const resultado = await this.aplicarDescuentoIndividual(descuento, items, subtotal - totalDescuento);
      
      if (resultado.montoDescuento > 0) {
        descuentosAplicados.push(resultado);
        totalDescuento += resultado.montoDescuento;
      }

      // No aplicar mÃ¡s descuentos si ya se descuenta todo
      if (totalDescuento >= subtotal) break;
    }

    return {
      descuentosAplicados,
      subtotal,
      totalDescuento: Math.min(totalDescuento, subtotal),
      total: Math.max(0, subtotal - totalDescuento)
    };
  }

  // NUEVO: Obtener descuentos aplicables automÃ¡ticamente
  private async obtenerDescuentosAplicables(
    items: ItemCarrito[],
    subtotal: number
  ): Promise<Descuento[]> {
    const descuentosActivos = await this.listarActivos();
    const aplicables: Descuento[] = [];

    for (const descuento of descuentosActivos) {
      // Verificar monto mÃ­nimo
      if (subtotal < descuento.MontoMinimo) continue;

      // Verificar si aplica a algÃºn producto/categorÃ­a del carrito
      if (descuento.IdProductoAplica) {
        const tieneProducto = items.some(i => i.IdProducto === descuento.IdProductoAplica);
        if (tieneProducto) aplicables.push(descuento);
      } else if (descuento.IdCategoriaAplica) {
        const tieneCategoria = items.some(i => i.IdCategoria === descuento.IdCategoriaAplica);
        if (tieneCategoria) aplicables.push(descuento);
      } else if (!descuento.CodigoCupon) {
        // Descuento general (sin categorÃ­a/producto especÃ­fico y sin cupÃ³n)
        aplicables.push(descuento);
      }
    }

    return aplicables;
  }

  // NUEVO: Ordenar descuentos por precedencia
  private ordenarPorPrecedencia(descuentos: Descuento[]): Descuento[] {
    return descuentos.sort((a, b) => {
      // 1. Promociones especiales (2x1, 3x2) primero
      const tipoOrdenA = ['2x1', '3x2', 'combo'].includes(a.Tipo) ? 0 : 1;
      const tipoOrdenB = ['2x1', '3x2', 'combo'].includes(b.Tipo) ? 0 : 1;
      if (tipoOrdenA !== tipoOrdenB) return tipoOrdenA - tipoOrdenB;

      // 2. Descuentos especÃ­ficos antes que generales
      const especificidadA = a.IdProductoAplica ? 0 : a.IdCategoriaAplica ? 1 : 2;
      const especificidadB = b.IdProductoAplica ? 0 : b.IdCategoriaAplica ? 1 : 2;
      if (especificidadA !== especificidadB) return especificidadA - especificidadB;

      // 3. Mayor descuento primero
      const valorA = a.Tipo === 'porcentaje' ? (a.Valor || 0) : (a.Valor || 0) * 100;
      const valorB = b.Tipo === 'porcentaje' ? (b.Valor || 0) : (b.Valor || 0) * 100;
      return valorB - valorA;
    });
  }

  // NUEVO: Aplicar un descuento individual
  private async aplicarDescuentoIndividual(
    descuento: Descuento,
    items: ItemCarrito[],
    subtotalRestante: number
  ): Promise<DescuentoAplicado> {
    let montoDescuento = 0;
    const itemsAfectados: number[] = [];

    switch (descuento.Tipo) {
      case 'porcentaje':
        if (descuento.IdProductoAplica) {
          // Solo al producto especÃ­fico
          const item = items.find(i => i.IdProducto === descuento.IdProductoAplica);
          if (item) {
            montoDescuento = (item.Subtotal * (descuento.Valor || 0)) / 100;
            itemsAfectados.push(item.IdProducto);
          }
        } else if (descuento.IdCategoriaAplica) {
          // Solo a la categorÃ­a
          const itemsCategoria = items.filter(i => i.IdCategoria === descuento.IdCategoriaAplica);
          const subtotalCategoria = itemsCategoria.reduce((sum, i) => sum + i.Subtotal, 0);
          montoDescuento = (subtotalCategoria * (descuento.Valor || 0)) / 100;
          itemsAfectados.push(...itemsCategoria.map(i => i.IdProducto));
        } else {
          // A todo el carrito
          montoDescuento = (subtotalRestante * (descuento.Valor || 0)) / 100;
          itemsAfectados.push(...items.map(i => i.IdProducto));
        }
        break;

      case 'monto_fijo':
        montoDescuento = Math.min(descuento.Valor || 0, subtotalRestante);
        itemsAfectados.push(...items.map(i => i.IdProducto));
        break;

      case '2x1':
        const item2x1 = items.find(i => i.IdProducto === descuento.IdProductoAplica);
        if (item2x1 && item2x1.Cantidad >= 2) {
          montoDescuento = item2x1.Subtotal * 0.5;
          itemsAfectados.push(item2x1.IdProducto);
        }
        break;

      case '3x2':
        const item3x2 = items.find(i => i.IdProducto === descuento.IdProductoAplica);
        if (item3x2 && item3x2.Cantidad >= 3) {
          const itemsGratis = Math.floor(item3x2.Cantidad / 3);
          montoDescuento = itemsGratis * item3x2.PrecioUnitario;
          itemsAfectados.push(item3x2.IdProducto);
        }
        break;
    }

    return {
      descuento,
      montoDescuento: Math.min(montoDescuento, subtotalRestante),
      descripcion: this.generarDescripcion(descuento, montoDescuento),
      itemsAfectados
    };
  }

  // NUEVO: Generar descripciÃ³n legible del descuento
  private generarDescripcion(descuento: Descuento, monto: number): string {
    let desc = descuento.Nombre;
    
    if (descuento.Tipo === 'porcentaje') {
      desc += ` (-${descuento.Valor}%)`;
    } else if (descuento.Tipo === 'monto_fijo') {
      desc += ` (-$${descuento.Valor})`;
    }

    return `${desc}: -$${monto.toFixed(2)}`;
  }

  // ==================== REGISTRO Y ESTADÃSTICAS ====================
  
  async registrarUso(
    idDescuento: number,
    idVenta: number,
    montoDescuento: number
  ): Promise<void> {
    await pool.query(
      'CALL sp_RegistrarUsoDescuento(?, ?, ?)',
      [idDescuento, idVenta, montoDescuento]
    );
  }

  async obtenerPorVenta(idVenta: number): Promise<VentaDescuento[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT 
        vd.*,
        d.Nombre AS DescuentoNombre,
        d.Tipo AS TipoDescuento
      FROM VentaDescuentos vd
      INNER JOIN Descuentos d ON vd.IdDescuento = d.IdDescuento
      WHERE vd.IdVenta = ?`,
      [idVenta]
    );

    return rows.map(row => ({
      IdVentaDescuento: row.IdVentaDescuento,
      IdVenta: row.IdVenta,
      IdDescuento: row.IdDescuento,
      MontoDescuento: parseFloat(row.MontoDescuento),
      TipoDescuento: row.TipoDescuento,
      DescripcionDescuento: row.DescripcionDescuento
    }));
  }

  async obtenerEstadisticas(): Promise<any> {
    const [rows] = await pool.query<RowDataPacket[]>(`
      SELECT 
        COUNT(*) AS TotalDescuentos,
        SUM(CASE WHEN Activo = TRUE THEN 1 ELSE 0 END) AS Activos,
        SUM(CASE WHEN NOW() BETWEEN FechaInicio AND FechaFin THEN 1 ELSE 0 END) AS Vigentes,
        SUM(UsosActuales) AS UsosTotal,
        COALESCE((SELECT SUM(MontoDescuento) FROM VentaDescuentos), 0) AS AhorroTotal
      FROM Descuentos
    `);

    return rows[0];
  }

  // NUEVO: Top descuentos mÃ¡s usados
  async obtenerTopDescuentos(limite: number = 10): Promise<any[]> {
    const [rows] = await pool.query<RowDataPacket[]>(`
      SELECT 
        d.IdDescuento,
        d.Nombre,
        d.Tipo,
        COUNT(vd.IdVentaDescuento) AS VecesUsado,
        SUM(vd.MontoDescuento) AS AhorroTotal,
        AVG(vd.MontoDescuento) AS AhorroPromedio
      FROM Descuentos d
      INNER JOIN VentaDescuentos vd ON d.IdDescuento = vd.IdDescuento
      GROUP BY d.IdDescuento, d.Nombre, d.Tipo
      ORDER BY VecesUsado DESC
      LIMIT ?
    `, [limite]);

    return rows;
  }

  // ==================== HELPERS ====================
  
  private mapRowToDescuento(row: any): Descuento {
    return {
      IdDescuento: row.IdDescuento,
      Nombre: row.Nombre,
      Descripcion: row.Descripcion,
      Tipo: row.Tipo,
      Valor: row.Valor ? parseFloat(row.Valor) : undefined,
      FechaInicio: row.FechaInicio,
      FechaFin: row.FechaFin,
      Activo: Boolean(row.Activo),
      MontoMinimo: parseFloat(row.MontoMinimo),
      IdCategoriaAplica: row.IdCategoriaAplica,
      IdProductoAplica: row.IdProductoAplica,
      CodigoCupon: row.CodigoCupon,
      UsosMaximos: row.UsosMaximos,
      UsosActuales: row.UsosActuales || 0,
      ProductosCombo: row.ProductosCombo,
      CreadoPor: row.CreadoPor,
      FechaCreacion: row.FechaCreacion,
      CategoriaNombre: row.CategoriaNombre,
      ProductoNombre: row.ProductoNombre,
      DiasRestantes: row.DiasRestantes,
      PorcentajeUso: row.PorcentajeUso
    };
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\historialSesion.repository.ts
================================================================================
    // backend/src/repositories/historialSesion.repository.ts
    import { pool } from '../config/database';
    import { HistorialSesion } from '../models';
    import { RowDataPacket, ResultSetHeader } from 'mysql2';

    export class HistorialSesionRepository {
    async registrar(sesion: HistorialSesion): Promise<number> {
        const [result] = await pool.query<ResultSetHeader>(
        `INSERT INTO HistorialSesiones 
        (IdUsuario, DireccionIP, Navegador, Dispositivo, SistemaOperativo, Exitoso, MotivoFallo)
        VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
            sesion.IdUsuario,
            sesion.DireccionIP,
            sesion.Navegador,
            sesion.Dispositivo,
            sesion.SistemaOperativo,
            sesion.Exitoso,
            sesion.MotivoFallo || null
        ]
        );
        return result.insertId;
    }

    async listar(limite: number = 100): Promise<HistorialSesion[]> {
        const [rows] = await pool.query<RowDataPacket[]>(
        `SELECT 
            hs.IdSesion, hs.IdUsuario, hs.FechaHora, hs.DireccionIP,
            hs.Navegador, hs.Dispositivo, hs.SistemaOperativo, hs.Exitoso, hs.MotivoFallo,
            CONCAT(u.Nombre, ' ', u.Apellido) as UsuarioNombre,
            u.Usuario as UsuarioUsername
        FROM HistorialSesiones hs
        INNER JOIN Usuarios u ON hs.IdUsuario = u.IdUsuario
        ORDER BY hs.FechaHora DESC
        LIMIT ?`,
        [limite]
        );

        return rows.map(row => ({
        IdSesion: row.IdSesion,
        IdUsuario: row.IdUsuario,
        FechaHora: row.FechaHora,
        DireccionIP: row.DireccionIP,
        Navegador: row.Navegador,
        Dispositivo: row.Dispositivo,
        SistemaOperativo: row.SistemaOperativo,
        Exitoso: Boolean(row.Exitoso),
        MotivoFallo: row.MotivoFallo,
        Usuario: {
            IdUsuario: row.IdUsuario,
            Nombre: row.UsuarioNombre,
            Apellido: '',
            UsuarioNombre: row.UsuarioUsername,
            IdRol: 0,
            Activo: true
        }
        }));
    }

    async listarPorUsuario(idUsuario: number, limite: number = 50): Promise<HistorialSesion[]> {
        const [rows] = await pool.query<RowDataPacket[]>(
        `SELECT 
            IdSesion, IdUsuario, FechaHora, DireccionIP,
            Navegador, Dispositivo, SistemaOperativo, Exitoso, MotivoFallo
        FROM HistorialSesiones
        WHERE IdUsuario = ?
        ORDER BY FechaHora DESC
        LIMIT ?`,
        [idUsuario, limite]
        );

        return rows.map(row => ({
        IdSesion: row.IdSesion,
        IdUsuario: row.IdUsuario,
        FechaHora: row.FechaHora,
        DireccionIP: row.DireccionIP,
        Navegador: row.Navegador,
        Dispositivo: row.Dispositivo,
        SistemaOperativo: row.SistemaOperativo,
        Exitoso: Boolean(row.Exitoso),
        MotivoFallo: row.MotivoFallo
        }));
    }

    async obtenerEstadisticas(idUsuario?: number): Promise<any> {
        const whereClause = idUsuario ? 'WHERE IdUsuario = ?' : '';
        const params = idUsuario ? [idUsuario] : [];

        const [rows] = await pool.query<RowDataPacket[]>(
        `SELECT 
            COUNT(*) as TotalSesiones,
            SUM(CASE WHEN Exitoso = 1 THEN 1 ELSE 0 END) as SesionesExitosas,
            SUM(CASE WHEN Exitoso = 0 THEN 1 ELSE 0 END) as SesionesFallidas,
            COUNT(DISTINCT DireccionIP) as IPsUnicas,
            MAX(FechaHora) as UltimoAcceso
        FROM HistorialSesiones
        ${whereClause}`,
        params
        );

        return rows[0];
    }
    }

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\notificacion.repository.ts
================================================================================
// Backend/src/repositories/notificacion.repository.ts
import { pool } from '../config/database';
import { Notificacion, EstadisticasNotificaciones } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export class NotificacionRepository {
  
  // Listar notificaciones (con filtros opcionales)
  async listar(filtros?: {
    leida?: boolean;
    prioridad?: string;
    tipo?: string;
    limite?: number;
  }): Promise<Notificacion[]> {
    let query = `
      SELECT 
        n.IdNotificacion, n.Tipo, n.Titulo, n.Mensaje,
        n.IdProducto, n.IdUsuario, n.Prioridad, n.Leida,
        n.FechaCreacion, n.FechaLeida, n.Icono, n.Color,
        p.Nombre AS ProductoNombre,
        p.Stock AS ProductoStock,
        p.StockMinimo AS ProductoStockMinimo
      FROM Notificaciones n
      LEFT JOIN Productos p ON n.IdProducto = p.IdProducto
      WHERE 1=1
    `;
    
    const params: any[] = [];
    
    if (filtros?.leida !== undefined) {
      query += ' AND n.Leida = ?';
      params.push(filtros.leida);
    }
    
    if (filtros?.prioridad) {
      query += ' AND n.Prioridad = ?';
      params.push(filtros.prioridad);
    }
    
    if (filtros?.tipo) {
      query += ' AND n.Tipo = ?';
      params.push(filtros.tipo);
    }
    
    query += `
      ORDER BY 
        FIELD(n.Prioridad, 'critica', 'alta', 'media', 'baja'),
        n.FechaCreacion DESC
    `;
    
    if (filtros?.limite) {
      query += ' LIMIT ?';
      params.push(filtros.limite);
    }
    
    const [rows] = await pool.query<RowDataPacket[]>(query, params);
    
    return rows.map(row => ({
      IdNotificacion: row.IdNotificacion,
      Tipo: row.Tipo,
      Titulo: row.Titulo,
      Mensaje: row.Mensaje,
      IdProducto: row.IdProducto,
      IdUsuario: row.IdUsuario,
      Prioridad: row.Prioridad,
      Leida: Boolean(row.Leida),
      FechaCreacion: row.FechaCreacion,
      FechaLeida: row.FechaLeida,
      Icono: row.Icono,
      Color: row.Color,
      Producto: row.ProductoNombre ? {
        Nombre: row.ProductoNombre,
        Stock: row.ProductoStock,
        StockMinimo: row.ProductoStockMinimo
      } : undefined
    }));
  }
  
  // Obtener estadÃ­sticas
  async obtenerEstadisticas(): Promise<EstadisticasNotificaciones> {
    const [rows] = await pool.query<RowDataPacket[]>(`
      SELECT 
        COUNT(*) AS TotalNotificaciones,
        SUM(CASE WHEN Leida = FALSE THEN 1 ELSE 0 END) AS NoLeidas,
        SUM(CASE WHEN Prioridad = 'critica' THEN 1 ELSE 0 END) AS Criticas,
        SUM(CASE WHEN Prioridad = 'alta' THEN 1 ELSE 0 END) AS Altas
      FROM Notificaciones
    `);
    
    return {
      TotalNotificaciones: rows[0].TotalNotificaciones || 0,
      NoLeidas: rows[0].NoLeidas || 0,
      Criticas: rows[0].Criticas || 0,
      Altas: rows[0].Altas || 0
    };
  }
  
  // Marcar como leÃ­da
  async marcarLeida(idNotificacion: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Notificaciones 
       SET Leida = TRUE, FechaLeida = NOW() 
       WHERE IdNotificacion = ?`,
      [idNotificacion]
    );
    return result.affectedRows > 0;
  }
  
  // Marcar todas como leÃ­das
  async marcarTodasLeidas(idUsuario?: number): Promise<number> {
    let query = `UPDATE Notificaciones SET Leida = TRUE, FechaLeida = NOW() WHERE Leida = FALSE`;
    const params: any[] = [];
    
    if (idUsuario) {
      query += ' AND (IdUsuario IS NULL OR IdUsuario = ?)';
      params.push(idUsuario);
    }
    
    const [result] = await pool.query<ResultSetHeader>(query, params);
    return result.affectedRows;
  }
  
  // Eliminar notificaciÃ³n
  async eliminar(idNotificacion: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'DELETE FROM Notificaciones WHERE IdNotificacion = ?',
      [idNotificacion]
    );
    return result.affectedRows > 0;
  }
  
  // Limpiar notificaciones antiguas (mÃ¡s de 30 dÃ­as leÃ­das)
  async limpiarAntiguas(): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(`
      DELETE FROM Notificaciones
      WHERE Leida = TRUE
        AND FechaLeida < DATE_SUB(NOW(), INTERVAL 30 DAY)
    `);
    return result.affectedRows;
  }
  
  // Crear notificaciÃ³n manual (opcional, para futuras features)
  async crear(notificacion: Omit<Notificacion, 'IdNotificacion'>): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(
      `INSERT INTO Notificaciones 
       (Tipo, Titulo, Mensaje, IdProducto, IdUsuario, Prioridad, Icono, Color)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        notificacion.Tipo,
        notificacion.Titulo,
        notificacion.Mensaje,
        notificacion.IdProducto || null,
        notificacion.IdUsuario || null,
        notificacion.Prioridad,
        notificacion.Icono || 'bell',
        notificacion.Color || 'blue'
      ]
    );
    return result.insertId;
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\producto.repository.ts
================================================================================
// Backend/src/repositories/producto.repository.ts

import { pool } from '../config/database';
import { Producto } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export class ProductoRepository {
  async listar(): Promise<Producto[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT p.IdProducto, p.Nombre, p.CodigoBarras, p.IdCategoria, c.Nombre as CategoriaNombre,
              p.Precio, p.Stock, p.Estado, p.Descripcion, p.StockMinimo,
              p.FechaRegistro, p.EsProductoFinal
       FROM Productos p
       INNER JOIN Categorias c ON p.IdCategoria = c.IdCategoria`
    );

    return rows.map(row => ({
      IdProducto: row.IdProducto,
      Nombre: row.Nombre,
      CodigoBarras: row.CodigoBarras,
      IdCategoria: row.IdCategoria,
      Precio: parseFloat(row.Precio),
      Stock: row.Stock,
      Estado: Boolean(row.Estado),
      Descripcion: row.Descripcion,
      StockMinimo: row.StockMinimo,
      FechaRegistro: row.FechaRegistro,
      EsProductoFinal: Boolean(row.EsProductoFinal),
      Categoria: {
        IdCategoria: row.IdCategoria,
        Nombre: row.CategoriaNombre
      }
    }));
  }

  async registrar(producto: Producto): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(
      `INSERT INTO Productos (Nombre, CodigoBarras, IdCategoria, Precio, Stock, Estado,
                              Descripcion, StockMinimo, FechaRegistro, EsProductoFinal)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), ?)`,
      [
        producto.Nombre,
        producto.CodigoBarras || null,
        producto.IdCategoria,
        producto.Precio,
        producto.Stock,
        producto.Estado,
        producto.Descripcion,
        producto.StockMinimo,
        producto.EsProductoFinal
      ]
    );

    return result.insertId;
  }

  async editar(producto: Producto): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Productos SET Nombre = ?, CodigoBarras = ?, IdCategoria = ?, Precio = ?, Stock = ?,
                           Estado = ?, Descripcion = ?, StockMinimo = ?, EsProductoFinal = ?
       WHERE IdProducto = ?`,
      [
        producto.Nombre,
        producto.CodigoBarras || null,
        producto.IdCategoria,
        producto.Precio,
        producto.Stock,
        producto.Estado,
        producto.Descripcion,
        producto.StockMinimo,
        producto.EsProductoFinal,
        producto.IdProducto
      ]
    );

    return result.affectedRows > 0;
  }

  async eliminar(idProducto: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'UPDATE Productos SET Estado = 0 WHERE IdProducto = ?',
      [idProducto]
    );

    return result.affectedRows > 0;
  }

  async actualizarStock(idProducto: number, cantidad: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      'UPDATE Productos SET Stock = Stock - ? WHERE IdProducto = ?',
      [cantidad, idProducto]
    );

    return result.affectedRows > 0;
  }

  // Buscar por cÃ³digo de barras
  async buscarPorCodigo(codigoBarras: string): Promise<Producto | null> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT p.IdProducto, p.Nombre, p.CodigoBarras, p.IdCategoria, c.Nombre as CategoriaNombre,
              p.Precio, p.Stock, p.Estado, p.Descripcion, p.StockMinimo,
              p.FechaRegistro, p.EsProductoFinal
       FROM Productos p
       INNER JOIN Categorias c ON p.IdCategoria = c.IdCategoria
       WHERE p.CodigoBarras = ? AND p.Estado = 1`,
      [codigoBarras]
    );

    if (rows.length === 0) return null;

    const row = rows[0];
    return {
      IdProducto: row.IdProducto,
      Nombre: row.Nombre,
      CodigoBarras: row.CodigoBarras,
      IdCategoria: row.IdCategoria,
      Precio: parseFloat(row.Precio),
      Stock: row.Stock,
      Estado: Boolean(row.Estado),
      Descripcion: row.Descripcion,
      StockMinimo: row.StockMinimo,
      FechaRegistro: row.FechaRegistro,
      EsProductoFinal: Boolean(row.EsProductoFinal),
      Categoria: {
        IdCategoria: row.IdCategoria,
        Nombre: row.CategoriaNombre
      }
    };
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\usuario.repository.ts
================================================================================
// Backend/src/repositories/usuario.repository.ts

import { pool } from '../config/database';
import { Usuario } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export class UsuarioRepository {
  async listar(): Promise<Usuario[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT u.IdUsuario, u.Nombre, u.Apellido, u.Usuario as UsuarioNombre,
              u.ClaveHash, u.IdRol, r.Rol as RolNombre, u.Activo, u.FechaRegistro,
              u.FotoPerfil, u.Telefono, u.Email, u.Direccion, u.FechaNacimiento
       FROM Usuarios u
       INNER JOIN Roles r ON u.IdRol = r.IdRol`
    );

    return rows.map(row => ({
      IdUsuario: row.IdUsuario,
      Nombre: row.Nombre,
      Apellido: row.Apellido,
      UsuarioNombre: row.UsuarioNombre,
      ClaveHash: row.ClaveHash,
      IdRol: row.IdRol,
      Activo: Boolean(row.Activo),
      FechaRegistro: row.FechaRegistro,
      FotoPerfil: row.FotoPerfil,
      Telefono: row.Telefono,
      Email: row.Email,
      Direccion: row.Direccion,
      FechaNacimiento: row.FechaNacimiento,
      Rol: {
        IdRol: row.IdRol,
        RolNombre: row.RolNombre
      }
    }));
  }

  async obtenerPorId(idUsuario: number): Promise<Usuario | null> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT u.IdUsuario, u.Nombre, u.Apellido, u.Usuario as UsuarioNombre,
              u.IdRol, r.Rol as RolNombre, u.Activo, u.FechaRegistro,
              u.FotoPerfil, u.Telefono, u.Email, u.Direccion, u.FechaNacimiento
       FROM Usuarios u
       INNER JOIN Roles r ON u.IdRol = r.IdRol
       WHERE u.IdUsuario = ?`,
      [idUsuario]
    );

    if (rows.length === 0) return null;

    const row = rows[0];
    return {
      IdUsuario: row.IdUsuario,
      Nombre: row.Nombre,
      Apellido: row.Apellido,
      UsuarioNombre: row.UsuarioNombre,
      IdRol: row.IdRol,
      Activo: Boolean(row.Activo),
      FechaRegistro: row.FechaRegistro,
      FotoPerfil: row.FotoPerfil,
      Telefono: row.Telefono,
      Email: row.Email,
      Direccion: row.Direccion,
      FechaNacimiento: row.FechaNacimiento,
      Rol: {
        IdRol: row.IdRol,
        RolNombre: row.RolNombre
      }
    };
  }

  async login(usuario: string, claveHash: string): Promise<Usuario | null> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT u.IdUsuario, u.Nombre, u.Apellido, u.Usuario as UsuarioNombre,
              u.ClaveHash, u.IdRol, r.Rol as RolNombre, u.Activo, u.FechaRegistro,
              u.FotoPerfil, u.Telefono, u.Email, u.Direccion, u.FechaNacimiento
       FROM Usuarios u
       INNER JOIN Roles r ON u.IdRol = r.IdRol
       WHERE u.Usuario = ? AND u.ClaveHash = ? AND u.Activo = 1`,
      [usuario, claveHash]
    );

    if (rows.length === 0) return null;

    const row = rows[0];
    return {
      IdUsuario: row.IdUsuario,
      Nombre: row.Nombre,
      Apellido: row.Apellido,
      UsuarioNombre: row.UsuarioNombre,
      ClaveHash: row.ClaveHash,
      IdRol: row.IdRol,
      Activo: Boolean(row.Activo),
      FechaRegistro: row.FechaRegistro,
      FotoPerfil: row.FotoPerfil,
      Telefono: row.Telefono,
      Email: row.Email,
      Direccion: row.Direccion,
      FechaNacimiento: row.FechaNacimiento,
      Rol: {
        IdRol: row.IdRol,
        RolNombre: row.RolNombre
      }
    };
  }

  async registrar(usuario: Usuario): Promise<number> {
    const [result] = await pool.query<ResultSetHeader>(
      `INSERT INTO Usuarios (Nombre, Apellido, Usuario, ClaveHash, IdRol, Activo, FechaRegistro)
       VALUES (?, ?, ?, ?, ?, ?, NOW())`,
      [usuario.Nombre, usuario.Apellido, usuario.UsuarioNombre, usuario.ClaveHash, usuario.IdRol, usuario.Activo]
    );
    return result.insertId;
  }

  async editar(usuario: Usuario): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Usuarios SET Nombre = ?, Apellido = ?, Usuario = ?, IdRol = ?, Activo = ?
       WHERE IdUsuario = ?`,
      [usuario.Nombre, usuario.Apellido, usuario.UsuarioNombre, usuario.IdRol, usuario.Activo, usuario.IdUsuario]
    );
    return result.affectedRows > 0;
  }

  // Actualizar perfil del usuario
  async actualizarPerfil(idUsuario: number, datos: Partial<Usuario>): Promise<boolean> {
    const campos: string[] = [];
    const valores: any[] = [];

    if (datos.Nombre !== undefined) {
      campos.push('Nombre = ?');
      valores.push(datos.Nombre);
    }
    if (datos.Apellido !== undefined) {
      campos.push('Apellido = ?');
      valores.push(datos.Apellido);
    }
    if (datos.FotoPerfil !== undefined) {
      campos.push('FotoPerfil = ?');
      valores.push(datos.FotoPerfil);
    }
    if (datos.Telefono !== undefined) {
      campos.push('Telefono = ?');
      valores.push(datos.Telefono);
    }
    if (datos.Email !== undefined) {
      campos.push('Email = ?');
      valores.push(datos.Email);
    }
    if (datos.Direccion !== undefined) {
      campos.push('Direccion = ?');
      valores.push(datos.Direccion);
    }
    if (datos.FechaNacimiento !== undefined) {
      campos.push('FechaNacimiento = ?');
      valores.push(datos.FechaNacimiento);
    }

    if (campos.length === 0) return false;

    valores.push(idUsuario);

    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Usuarios SET ${campos.join(', ')} WHERE IdUsuario = ?`,
      valores
    );

    return result.affectedRows > 0;
  }

  async cambiarClave(idUsuario: number, nuevaClaveHash: string): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Usuarios SET ClaveHash = ? WHERE IdUsuario = ?`,
      [nuevaClaveHash, idUsuario]
    );
    return result.affectedRows > 0;
  }

  async eliminar(idUsuario: number): Promise<boolean> {
    const [result] = await pool.query<ResultSetHeader>(
      `UPDATE Usuarios SET Activo = 0 WHERE IdUsuario = ?`,
      [idUsuario]
    );
    return result.affectedRows > 0;
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\repositories\venta.repository.ts
================================================================================
import { pool } from '../config/database';
import { Venta, DetalleVenta } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

export class VentaRepository {
  async registrarVenta(venta: Venta): Promise<number> {
    const connection = await pool.getConnection();
    
    try {
      await connection.beginTransaction();

      // Insertar venta
      const [ventaResult] = await connection.query<ResultSetHeader>(
        `INSERT INTO Ventas (
            Fecha, IdUsuario, Subtotal, Descuento, Total, 
            MetodoPago, Comentario, Estado, FechaVenta
         ) VALUES (NOW(), ?, ?, ?, ?, ?, ?, ?, NOW())`,
        [
          venta.IdUsuario, 
          // Si el frontend no envÃ­a subtotal, calculamos revertiendo el total (fallback)
          venta.Subtotal || venta.Total, 
          venta.Descuento || 0, // AsegÃºrate que tu modelo Venta tenga este campo o mappedalo
          venta.Total, 
          venta.MetodoPago, 
          venta.Comentario || '', 
          venta.Estado ? '1' : '0'
        ]
      );
      const idVenta = ventaResult.insertId;

      // Insertar detalles de productos
      if (venta.DetallesVenta) {
        for (const detalle of venta.DetallesVenta) {
          await connection.query(
            `INSERT INTO DetalleVenta (IdVenta, IdProducto, Cantidad, PrecioUnitario, Subtotal)
             VALUES (?, ?, ?, ?, ?)`,
            [idVenta, detalle.IdProducto, detalle.Cantidad, detalle.PrecioUnitario, detalle.Subtotal]
          );
          // Actualizar stock...
          await connection.query(
            'UPDATE Productos SET Stock = Stock - ? WHERE IdProducto = ?',
            [detalle.Cantidad, detalle.IdProducto]
          );
        }
      }

      // Insertar historial de descuentos
      if (venta.DescuentosAplicados && venta.DescuentosAplicados.length > 0) {
        for (const desc of venta.DescuentosAplicados) {
           await connection.query(
             `INSERT INTO VentaDescuentos (IdVenta, IdDescuento, MontoDescuento, TipoDescuento, DescripcionDescuento)
              VALUES (?, ?, ?, ?, ?)`,
             [
                idVenta, 
                desc.IdDescuento, 
                desc.MontoDescuento, 
                desc.TipoDescuento, 
                desc.DescripcionDescuento || 'Descuento aplicado'
             ]
           );
           
           // Actualizar contador de usos
           await connection.query(
             'UPDATE Descuentos SET UsosActuales = UsosActuales + 1 WHERE IdDescuento = ?',
             [desc.IdDescuento]
           );
        }
      }

      await connection.commit();
      return idVenta;
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  async listar(): Promise<Venta[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT v.IdVenta, v.Fecha, v.IdUsuario,
              CONCAT(u.Nombre, ' ', u.Apellido) as NombreCompleto,
              v.Total, v.MetodoPago,
              IFNULL(v.Comentario, '') as Comentario,
              v.Estado, v.FechaVenta,
              IFNULL((SELECT SUM(dv.Cantidad) FROM DetalleVenta dv WHERE dv.IdVenta = v.IdVenta), 0) AS CantidadTotalProductos
       FROM Ventas v
       INNER JOIN Usuarios u ON v.IdUsuario = u.IdUsuario
       ORDER BY v.FechaVenta DESC`
    );

    return rows.map(row => ({
      IdVenta: row.IdVenta,
      Fecha: row.Fecha,
      IdUsuario: row.IdUsuario,
      Total: parseFloat(row.Total),
      MetodoPago: row.MetodoPago,
      Comentario: row.Comentario,
      Estado: row.Estado === '1' || row.Estado === 1 || row.Estado === true,
      FechaVenta: row.FechaVenta,
      CantidadTotalProductos: row.CantidadTotalProductos,
      Usuario: {
        IdUsuario: row.IdUsuario,
        Nombre: row.NombreCompleto,
        Apellido: '',
        UsuarioNombre: '',
        IdRol: 0,
        Activo: true
      }
    }));
  }

  async listarPorUsuario(idUsuario: number): Promise<Venta[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT v.IdVenta, v.Fecha, v.IdUsuario,
              CONCAT(u.Nombre, ' ', u.Apellido) as NombreCompleto,
              v.Total, v.MetodoPago,
              IFNULL(v.Comentario, '') as Comentario,
              v.Estado, v.FechaVenta,
              IFNULL((SELECT SUM(dv.Cantidad) FROM DetalleVenta dv WHERE dv.IdVenta = v.IdVenta), 0) AS CantidadTotalProductos
       FROM Ventas v
       INNER JOIN Usuarios u ON v.IdUsuario = u.IdUsuario
       WHERE v.IdUsuario = ?
       ORDER BY v.FechaVenta DESC`,
      [idUsuario]
    );

    return rows.map(row => ({
      IdVenta: row.IdVenta,
      Fecha: row.Fecha,
      IdUsuario: row.IdUsuario,
      Total: parseFloat(row.Total),
      MetodoPago: row.MetodoPago,
      Comentario: row.Comentario,
      Estado: row.Estado === '1' || row.Estado === 1 || row.Estado === true,
      FechaVenta: row.FechaVenta,
      CantidadTotalProductos: row.CantidadTotalProductos,
      Usuario: {
        IdUsuario: row.IdUsuario,
        Nombre: row.NombreCompleto,
        Apellido: '',
        UsuarioNombre: '',
        IdRol: 0,
        Activo: true
      }
    }));
  }

  async obtenerDetalleVenta(idVenta: number): Promise<DetalleVenta[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT dv.IdDetalle, dv.IdVenta, dv.IdProducto,
              p.Nombre as ProductoNombre, dv.Cantidad, dv.PrecioUnitario, dv.Subtotal
       FROM DetalleVenta dv
       INNER JOIN Productos p ON dv.IdProducto = p.IdProducto
       WHERE dv.IdVenta = ?`,
      [idVenta]
    );

    return rows.map(row => ({
      IdDetalle: row.IdDetalle,
      IdVenta: row.IdVenta,
      IdProducto: row.IdProducto,
      Cantidad: row.Cantidad,
      PrecioUnitario: parseFloat(row.PrecioUnitario),
      Subtotal: parseFloat(row.Subtotal),
      Producto: {
        IdProducto: row.IdProducto,
        Nombre: row.ProductoNombre,
        IdCategoria: 0,
        Precio: 0,
        Stock: 0,
        Estado: true,
        StockMinimo: 0,
        EsProductoFinal: true
      }
    }));
  }

  async listarPorFechas(fechaInicio: Date, fechaFin: Date): Promise<Venta[]> {
    const [rows] = await pool.query<RowDataPacket[]>(
      `SELECT v.IdVenta, v.Fecha, v.IdUsuario,
              CONCAT(u.Nombre, ' ', u.Apellido) as NombreCompleto,
              v.Total, v.MetodoPago,
              IFNULL(v.Comentario, '') as Comentario,
              v.Estado, v.FechaVenta,
              IFNULL((SELECT SUM(dv.Cantidad) FROM DetalleVenta dv WHERE dv.IdVenta = v.IdVenta), 0) AS CantidadTotalProductos
       FROM Ventas v
       INNER JOIN Usuarios u ON v.IdUsuario = u.IdUsuario
       WHERE v.FechaVenta BETWEEN ? AND ?
       ORDER BY v.FechaVenta DESC`,
      [fechaInicio, fechaFin]
    );

    return rows.map(row => ({
      IdVenta: row.IdVenta,
      Fecha: row.Fecha,
      IdUsuario: row.IdUsuario,
      Total: parseFloat(row.Total),
      MetodoPago: row.MetodoPago,
      Comentario: row.Comentario,
      Estado: row.Estado === '1' || row.Estado === 1 || row.Estado === true,
      FechaVenta: row.FechaVenta,
      CantidadTotalProductos: row.CantidadTotalProductos,
      Usuario: {
        IdUsuario: row.IdUsuario,
        Nombre: row.NombreCompleto,
        Apellido: '',
        UsuarioNombre: '',
        IdRol: 0,
        Activo: true
      }
    }));
  }

  async verificarStock(idProducto: number, cantidad: number): Promise<{ disponible: boolean; mensaje: string }> {
    const [rows] = await pool.query<RowDataPacket[]>(
      'SELECT Stock, Nombre FROM Productos WHERE IdProducto = ?',
      [idProducto]
    );

    if (rows.length === 0) {
      return { disponible: false, mensaje: 'Producto no encontrado' };
    }

    const { Stock, Nombre } = rows[0];
    if (Stock >= cantidad) {
      return { disponible: true, mensaje: 'Stock disponible' };
    } else {
      return { disponible: false, mensaje: `Stock insuficiente para ${Nombre}. Disponible: ${Stock}` };
    }
  }
}

================================================================================
ğŸ“‚ RUTA: backend\src\routes\auth.routes.ts
================================================================================
// backend/src/routes/auth.routes.ts
import { Router } from 'express';
import { UsuarioRepository } from '../repositories/usuario.repository';
import { HistorialSesionRepository } from '../repositories/historialSesion.repository';
import { hashPasswordSHA256, generateToken } from '../utils/auth';
import { extractClientInfo } from '../utils/userAgent';

const router = Router();
const usuarioRepo = new UsuarioRepository();
const historialRepo = new HistorialSesionRepository();

// Login CON registro de historial
router.post('/login', async (req, res) => {
  const clientInfo = extractClientInfo(req);
  
  try {
    const { usuario, clave } = req.body;

    if (!usuario || !clave) {
      return res.status(400).json({ error: 'Usuario y contraseÃ±a son requeridos' });
    }

    // Hash de la contraseÃ±a
    const claveHash = hashPasswordSHA256(clave);

    // Buscar usuario
    const user = await usuarioRepo.login(usuario, claveHash);

    if (!user) {
      // Registrar intento fallido (si encontramos el usuario por nombre)
      const usuarios = await usuarioRepo.listar();
      const userByUsername = usuarios.find(u => u.UsuarioNombre === usuario);
      
      if (userByUsername) {
        await historialRepo.registrar({
          IdUsuario: userByUsername.IdUsuario!,
          DireccionIP: clientInfo.ip,
          Navegador: clientInfo.navegador,
          Dispositivo: clientInfo.dispositivo,
          SistemaOperativo: clientInfo.sistemaOperativo,
          Exitoso: false,
          MotivoFallo: 'ContraseÃ±a incorrecta'
        });
      }

      return res.status(401).json({ error: 'Usuario o contraseÃ±a incorrectos' });
    }

    // Registrar sesiÃ³n exitosa
    await historialRepo.registrar({
      IdUsuario: user.IdUsuario!,
      DireccionIP: clientInfo.ip,
      Navegador: clientInfo.navegador,
      Dispositivo: clientInfo.dispositivo,
      SistemaOperativo: clientInfo.sistemaOperativo,
      Exitoso: true
    });

    // Generar token
    const token = generateToken(user.IdUsuario!, user.UsuarioNombre, user.IdRol);

    // Remover el hash de la contraseÃ±a antes de enviar
    delete user.ClaveHash;

    res.json({
      message: 'Login exitoso',
      usuario: user,
      token
    });
  } catch (error: any) {
    console.error('Error en login:', error);
    res.status(500).json({ error: 'Error al procesar el login' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\categoria.routes.ts
================================================================================
import { Router, Request, Response  } from 'express';
import { CategoriaRepository } from '../repositories/categoria.repository';
import { authMiddleware, isAdmin } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';

const router = Router();
const categoriaRepo = new CategoriaRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar categorÃ­as
router.get('/', async (req, res) => {
  try {
    const categorias = await categoriaRepo.listar();
    res.json(categorias);
  } catch (error: any) {
    console.error('Error al listar categorÃ­as:', error);
    res.status(500).json({ error: 'Error al listar categorÃ­as' });
  }
});

// Registrar categorÃ­a (solo admin)
router.post(
  '/',
  isAdmin,
  [
    body('Nombre')
      .notEmpty().withMessage('Nombre es requerido')
      .isLength({ max: 100 }).withMessage('Nombre no puede exceder 100 caracteres')
  ],
  async (req: Request, res: Response) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const categoria = req.body;
      const idCategoria = await categoriaRepo.registrar(categoria);
      res.status(201).json({ 
        message: 'CategorÃ­a registrada exitosamente', 
        idCategoria 
      });
    } catch (error: any) {
      console.error('Error al registrar categorÃ­a:', error);
      res.status(500).json({ error: 'Error al registrar categorÃ­a' });
    }
  }
);

// Editar categorÃ­a (solo admin)
router.put(
  '/:id',
  isAdmin,
  [
    body('Nombre')
      .notEmpty().withMessage('Nombre es requerido')
      .isLength({ max: 100 }).withMessage('Nombre no puede exceder 100 caracteres')
  ],
  async (req: Request, res: Response) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const idCategoria = parseInt(req.params.id);
      const categoria = { ...req.body, IdCategoria: idCategoria };
      
      const resultado = await categoriaRepo.editar(categoria);
      if (resultado) {
        res.json({ message: 'CategorÃ­a actualizada exitosamente' });
      } else {
        res.status(404).json({ error: 'CategorÃ­a no encontrada' });
      }
    } catch (error: any) {
      console.error('Error al editar categorÃ­a:', error);
      res.status(500).json({ error: 'Error al editar categorÃ­a' });
    }
  }
);

// Eliminar categorÃ­a (solo admin)
router.delete('/:id', isAdmin, async (req, res) => {
  try {
    const idCategoria = parseInt(req.params.id);
    const resultado = await categoriaRepo.eliminar(idCategoria);

    if (resultado) {
      res.json({ message: 'CategorÃ­a eliminada exitosamente' });
    } else {
      res.status(404).json({ error: 'CategorÃ­a no encontrada' });
    }
  } catch (error: any) {
    console.error('Error al eliminar categorÃ­a:', error);
    // Verificar si hay productos asociados
    if (error.code === 'ER_ROW_IS_REFERENCED_2') {
      res.status(400).json({ 
        error: 'No se puede eliminar la categorÃ­a porque tiene productos asociados' 
      });
    } else {
      res.status(500).json({ error: 'Error al eliminar categorÃ­a' });
    }
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\descuento.routes.ts
================================================================================
// Backend/src/routes/descuento.routes.ts

import { Router, Response } from 'express';
import { DescuentoRepository } from '../repositories/descuento.repository';
import { authMiddleware, isAdmin, AuthRequest } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';

const router = Router();
const descuentoRepo = new DescuentoRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// ==================== RUTAS PÃšBLICAS (Cajeros y Admins) ====================

// Listar descuentos activos
router.get('/activos', async (_req: AuthRequest, res: Response): Promise<void> => {
  try {
    const descuentos = await descuentoRepo.listarActivos();
    res.json(descuentos);
  } catch (error) {
    console.error('Error al listar descuentos activos:', error);
    res.status(500).json({ error: 'Error al listar descuentos activos' });
  }
});

// Validar cupÃ³n
router.post('/validar-cupon', [
  body('codigo').notEmpty().withMessage('CÃ³digo de cupÃ³n requerido'),
  body('montoCompra').isFloat({ min: 0 }).withMessage('Monto de compra invÃ¡lido')
], async (req: AuthRequest, res: Response): Promise<void> => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({ errors: errors.array() });
    return;
  }

  try {
    const { codigo, montoCompra } = req.body;
    const resultado = await descuentoRepo.validarCupon(codigo, montoCompra);
    
    res.json(resultado);
  } catch (error) {
    console.error('Error al validar cupÃ³n:', error);
    res.status(500).json({ error: 'Error al validar cupÃ³n' });
  }
});

// Calcular descuento
router.post('/calcular', [
  body('idDescuento').isInt().withMessage('ID de descuento requerido'),
  body('subtotal').isFloat({ min: 0 }).withMessage('Subtotal invÃ¡lido')
], async (req: AuthRequest, res: Response): Promise<void> => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({ errors: errors.array() });
    return;
  }

  try {
    const { idDescuento, subtotal, idProducto, cantidad } = req.body;
    const itemSimulado = {
        IdProducto: idProducto,
        Cantidad: cantidad,
        PrecioUnitario: 0, // No necesario para este cÃ¡lculo
        Subtotal: subtotal
    };

    const montoDescuento = await descuentoRepo.calcularDescuentoItem(
      idDescuento,
      itemSimulado
    );
    
    res.json({ montoDescuento });
  } catch (error) {
    console.error('Error al calcular descuento:', error);
    res.status(500).json({ error: 'Error al calcular descuento' });
  }
});

// ==================== RUTAS ADMIN ====================

// Listar todos los descuentos (solo admin)
router.get('/', isAdmin, async (_req: AuthRequest, res: Response): Promise<void> => {
  try {
    const descuentos = await descuentoRepo.listar();
    res.json(descuentos);
  } catch (error) {
    console.error('Error al listar descuentos:', error);
    res.status(500).json({ error: 'Error al listar descuentos' });
  }
});

// Obtener descuento por ID (solo admin)
router.get('/:id', isAdmin, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const id = parseInt(req.params.id);
    const descuento = await descuentoRepo.obtenerPorId(id);
    
    if (!descuento) {
      res.status(404).json({ error: 'Descuento no encontrado' });
      return;
    }
    
    res.json(descuento);
  } catch (error) {
    console.error('Error al obtener descuento:', error);
    res.status(500).json({ error: 'Error al obtener descuento' });
  }
});

// Crear descuento (solo admin)
router.post('/', isAdmin, [
  body('Nombre').notEmpty().withMessage('Nombre requerido'),
  body('Tipo').isIn(['porcentaje', 'monto_fijo', '2x1', '3x2', 'combo']).withMessage('Tipo invÃ¡lido'),
  body('FechaInicio').isISO8601().withMessage('Fecha de inicio invÃ¡lida'),
  body('FechaFin').isISO8601().withMessage('Fecha fin invÃ¡lida'),
  body('MontoMinimo').isFloat({ min: 0 }).withMessage('Monto mÃ­nimo invÃ¡lido')
], async (req: AuthRequest, res: Response): Promise<void> => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({ errors: errors.array() });
    return;
  }

  try {
    const descuento = {
      ...req.body,
      CreadoPor: req.user?.userId
    };

    // Validaciones especÃ­ficas por tipo
    if (descuento.Tipo === 'porcentaje' && (descuento.Valor < 0 || descuento.Valor > 100)) {
      res.status(400).json({ error: 'El porcentaje debe estar entre 0 y 100' });
      return;
    }

    if (descuento.Tipo === 'monto_fijo' && descuento.Valor <= 0) {
      res.status(400).json({ error: 'El monto fijo debe ser mayor a 0' });
      return;
    }

    // Validar fechas
    const fechaInicio = new Date(descuento.FechaInicio);
    const fechaFin = new Date(descuento.FechaFin);
    
    if (fechaFin <= fechaInicio) {
      res.status(400).json({ error: 'La fecha fin debe ser posterior a la fecha de inicio' });
      return;
    }

    const id = await descuentoRepo.crear(descuento);
    res.status(201).json({ 
      message: 'Descuento creado exitosamente',
      idDescuento: id
    });
  } catch (error: any) {
    console.error('Error al crear descuento:', error);
    
    // Verificar error de cupÃ³n duplicado
    if (error.code === 'ER_DUP_ENTRY') {
      res.status(400).json({ error: 'El cÃ³digo de cupÃ³n ya existe' });
      return;
    }
    
    res.status(500).json({ error: 'Error al crear descuento' });
  }
});

// Actualizar descuento (solo admin)
router.put('/:id', isAdmin, [
  body('Nombre').notEmpty().withMessage('Nombre requerido'),
  body('Tipo').isIn(['porcentaje', 'monto_fijo', '2x1', '3x2', 'combo']).withMessage('Tipo invÃ¡lido'),
  body('FechaInicio').isISO8601().withMessage('Fecha de inicio invÃ¡lida'),
  body('FechaFin').isISO8601().withMessage('Fecha fin invÃ¡lida')
], async (req: AuthRequest, res: Response): Promise<void> => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(400).json({ errors: errors.array() });
    return;
  }

  try {
    const id = parseInt(req.params.id);
    const actualizado = await descuentoRepo.actualizar(id, req.body);
    
    if (!actualizado) {
      res.status(404).json({ error: 'Descuento no encontrado' });
      return;
    }
    
    res.json({ message: 'Descuento actualizado exitosamente' });
  } catch (error) {
    console.error('Error al actualizar descuento:', error);
    res.status(500).json({ error: 'Error al actualizar descuento' });
  }
});

// Eliminar descuento (solo admin)
router.delete('/:id', isAdmin, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const id = parseInt(req.params.id);
    const eliminado = await descuentoRepo.eliminar(id);
    
    if (!eliminado) {
      res.status(404).json({ error: 'Descuento no encontrado' });
      return;
    }
    
    res.json({ message: 'Descuento eliminado exitosamente' });
  } catch (error) {
    console.error('Error al eliminar descuento:', error);
    res.status(500).json({ error: 'Error al eliminar descuento' });
  }
});

// Activar/Desactivar descuento (solo admin)
router.patch('/:id/toggle', isAdmin, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const id = parseInt(req.params.id);
    const actualizado = await descuentoRepo.toggleActivo(id);
    
    if (!actualizado) {
      res.status(404).json({ error: 'Descuento no encontrado' });
      return;
    }
    
    res.json({ message: 'Estado actualizado exitosamente' });
  } catch (error) {
    console.error('Error al cambiar estado:', error);
    res.status(500).json({ error: 'Error al cambiar estado' });
  }
});

// Obtener estadÃ­sticas (solo admin)
router.get('/estadisticas/resumen', isAdmin, async (_req: AuthRequest, res: Response): Promise<void> => {
  try {
    const estadisticas = await descuentoRepo.obtenerEstadisticas();
    res.json(estadisticas);
  } catch (error) {
    console.error('Error al obtener estadÃ­sticas:', error);
    res.status(500).json({ error: 'Error al obtener estadÃ­sticas' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\historialSesion.routes.ts
================================================================================
// backend/src/routes/historialSesion.routes.ts
import { Router, Request, Response } from 'express';
import { HistorialSesionRepository } from '../repositories/historialSesion.repository';
import { authMiddleware, isAdmin, AuthRequest } from '../middleware/auth.middleware';

const router = Router();
const historialRepo = new HistorialSesionRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar todas las sesiones (solo admin)
router.get('/', isAdmin, async (_req: Request, res: Response): Promise<void> => {
  try {
    const limite = parseInt(_req.query.limite as string) || 100;
    const sesiones = await historialRepo.listar(limite);
    res.json(sesiones);
  } catch (error: any) {
    console.error('Error al listar sesiones:', error);
    res.status(500).json({ error: 'Error al listar sesiones' });
  }
});

// Listar sesiones de un usuario especÃ­fico
router.get('/usuario/:idUsuario', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = parseInt(req.params.idUsuario);

    // Verificar que sea admin o el mismo usuario
    if (req.user?.role !== 1 && req.user?.userId !== idUsuario) {
      res.status(403).json({ error: 'No autorizado' });
      return;
    }

    const limite = parseInt(req.query.limite as string) || 50;
    const sesiones = await historialRepo.listarPorUsuario(idUsuario, limite);
    res.json(sesiones);
  } catch (error: any) {
    console.error('Error al listar sesiones del usuario:', error);
    res.status(500).json({ error: 'Error al listar sesiones del usuario' });
  }
});

// Obtener estadÃ­sticas (admin ve todas, usuario ve solo las suyas)
router.get('/estadisticas/:idUsuario?', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = req.params.idUsuario ? parseInt(req.params.idUsuario) : undefined;

    // Si no es admin, solo puede ver sus propias estadÃ­sticas
    if (req.user?.role !== 1) {
      if (!idUsuario || idUsuario !== req.user?.userId) {
        res.status(403).json({ error: 'No autorizado' });
        return;
      }
    }

    const stats = await historialRepo.obtenerEstadisticas(idUsuario);
    res.json(stats);
  } catch (error: any) {
    console.error('Error al obtener estadÃ­sticas:', error);
    res.status(500).json({ error: 'Error al obtener estadÃ­sticas' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\notificacion.routes.ts
================================================================================
// Backend/src/routes/notificacion.routes.ts
import { Router, Response } from 'express';
import { NotificacionRepository } from '../repositories/notificacion.repository';
import { authMiddleware, isAdmin, AuthRequest } from '../middleware/auth.middleware';

const router = Router();
const notifRepo = new NotificacionRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar notificaciones
router.get('/', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { leida, prioridad, tipo, limite } = req.query;
    
    const filtros = {
      leida: leida === 'true' ? true : leida === 'false' ? false : undefined,
      prioridad: prioridad as string,
      tipo: tipo as string,
      limite: limite ? parseInt(limite as string) : 50
    };
    
    const notificaciones = await notifRepo.listar(filtros);
    res.json(notificaciones);
  } catch (error) {
    console.error('Error al listar notificaciones:', error);
    res.status(500).json({ error: 'Error al listar notificaciones' });
  }
});

// Obtener estadÃ­sticas
router.get('/estadisticas', async (_req: AuthRequest, res: Response): Promise<void> => {
  try {
    const stats = await notifRepo.obtenerEstadisticas();
    res.json(stats);
  } catch (error) {
    console.error('Error al obtener estadÃ­sticas:', error);
    res.status(500).json({ error: 'Error al obtener estadÃ­sticas' });
  }
});

// Marcar como leÃ­da
router.put('/:id/leer', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idNotificacion = parseInt(req.params.id);
    const resultado = await notifRepo.marcarLeida(idNotificacion);
    
    if (resultado) {
      res.json({ message: 'NotificaciÃ³n marcada como leÃ­da' });
    } else {
      res.status(404).json({ error: 'NotificaciÃ³n no encontrada' });
    }
  } catch (error) {
    console.error('Error al marcar notificaciÃ³n:', error);
    res.status(500).json({ error: 'Error al marcar notificaciÃ³n' });
  }
});

// Marcar todas como leÃ­das
router.put('/leer-todas', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = req.user?.userId;
    const count = await notifRepo.marcarTodasLeidas(idUsuario);
    
    res.json({ 
      message: `${count} notificaciones marcadas como leÃ­das`,
      count 
    });
  } catch (error) {
    console.error('Error al marcar todas:', error);
    res.status(500).json({ error: 'Error al marcar notificaciones' });
  }
});

// Eliminar notificaciÃ³n (solo admin)
router.delete('/:id', isAdmin, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idNotificacion = parseInt(req.params.id);
    const resultado = await notifRepo.eliminar(idNotificacion);
    
    if (resultado) {
      res.json({ message: 'NotificaciÃ³n eliminada' });
    } else {
      res.status(404).json({ error: 'NotificaciÃ³n no encontrada' });
    }
  } catch (error) {
    console.error('Error al eliminar notificaciÃ³n:', error);
    res.status(500).json({ error: 'Error al eliminar notificaciÃ³n' });
  }
});

// Limpiar notificaciones antiguas (solo admin)
router.delete('/limpiar/antiguas', isAdmin, async (_req: AuthRequest, res: Response): Promise<void> => {
  try {
    const count = await notifRepo.limpiarAntiguas();
    res.json({ 
      message: `${count} notificaciones antiguas eliminadas`,
      count 
    });
  } catch (error) {
    console.error('Error al limpiar notificaciones:', error);
    res.status(500).json({ error: 'Error al limpiar notificaciones' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\perfil.routes.ts
================================================================================
// Backend/src/routes/perfil.routes.ts - MEJORADO
import { Router, Response } from 'express';
import { UsuarioRepository } from '../repositories/usuario.repository';
import { authMiddleware, AuthRequest, isAdmin } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';
import { hashPasswordSHA256 } from '../utils/auth';

const router = Router();
const usuarioRepo = new UsuarioRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// ==================== RUTAS DE USUARIO COMÃšN ====================

// Obtener perfil del usuario actual
router.get('/mi-perfil', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = req.user?.userId;
    if (!idUsuario) {
      res.status(401).json({ error: 'Usuario no autenticado' });
      return;
    }

    const usuario = await usuarioRepo.obtenerPorId(idUsuario);
    
    if (!usuario) {
      res.status(404).json({ error: 'Usuario no encontrado' });
      return;
    }

    const { ClaveHash, ...usuarioSinClave } = usuario;
    res.json(usuarioSinClave);
  } catch (error: any) {
    console.error('Error al obtener perfil:', error);
    res.status(500).json({ error: 'Error al obtener perfil' });
  }
});

// Actualizar perfil del usuario actual
router.put(
  '/mi-perfil',
  [
    body('Nombre')
      .optional()
      .trim()
      .isLength({ min: 1, max: 100 })
      .withMessage('Nombre debe tener entre 1 y 100 caracteres'),
    body('Apellido')
      .optional()
      .trim()
      .isLength({ min: 1, max: 100 })
      .withMessage('Apellido debe tener entre 1 y 100 caracteres'),
    body('Telefono')
      .optional()
      .trim()
      .matches(/^[0-9\-\s\+\(\)]*$/)
      .withMessage('TelÃ©fono invÃ¡lido')
      .isLength({ max: 20 })
      .withMessage('TelÃ©fono no puede exceder 20 caracteres'),
    body('Email')
      .optional()
      .trim()
      .isEmail()
      .withMessage('Email invÃ¡lido')
      .isLength({ max: 100 })
      .withMessage('Email no puede exceder 100 caracteres'),
    body('Direccion')
      .optional()
      .trim()
      .isLength({ max: 255 })
      .withMessage('DirecciÃ³n no puede exceder 255 caracteres'),
    body('FechaNacimiento')
      .optional()
      .isISO8601()
      .withMessage('Fecha de nacimiento invÃ¡lida'),
    body('FotoPerfil')
      .optional()
      .custom((value) => {
        if (!value) return true;
        
        if (value.startsWith('data:image')) {
          const sizeInBytes = (value.length * 3) / 4;
          const sizeInMB = sizeInBytes / (1024 * 1024);
          if (sizeInMB > 2) {
            throw new Error('La imagen no puede exceder 2MB');
          }
          return true;
        }
        
        try {
          new URL(value);
          return true;
        } catch {
          throw new Error('Formato de imagen invÃ¡lido');
        }
      })
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = req.user?.userId;
      if (!idUsuario) {
        res.status(401).json({ error: 'Usuario no autenticado' });
        return;
      }

      const datos = req.body;
      const actualizado = await usuarioRepo.actualizarPerfil(idUsuario, datos);

      if (!actualizado) {
        res.status(404).json({ error: 'Usuario no encontrado' });
        return;
      }

      const usuarioActualizado = await usuarioRepo.obtenerPorId(idUsuario);
      
      if (usuarioActualizado) {
        const { ClaveHash, ...usuarioSinClave } = usuarioActualizado;
        res.json({
          message: 'Perfil actualizado exitosamente',
          usuario: usuarioSinClave
        });
      } else {
        res.status(404).json({ error: 'Error al obtener usuario actualizado' });
      }
    } catch (error: any) {
      console.error('Error al actualizar perfil:', error);
      res.status(500).json({ error: 'Error al actualizar perfil' });
    }
  }
);

// Cambiar MI contraseÃ±a (usuario propio)
router.put(
  '/mi-perfil/cambiar-clave',
  [
    body('claveActual')
      .notEmpty()
      .withMessage('ContraseÃ±a actual es requerida'),
    body('claveNueva')
      .isLength({ min: 6 })
      .withMessage('La nueva contraseÃ±a debe tener al menos 6 caracteres')
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = req.user?.userId;
      if (!idUsuario) {
        res.status(401).json({ error: 'Usuario no autenticado' });
        return;
      }

      const { claveActual, claveNueva } = req.body;

      // Verificar contraseÃ±a actual
      const usuario = await usuarioRepo.obtenerPorId(idUsuario);
      if (!usuario) {
        res.status(404).json({ error: 'Usuario no encontrado' });
        return;
      }

      const claveActualHash = hashPasswordSHA256(claveActual);
      if (usuario.ClaveHash !== claveActualHash) {
        res.status(401).json({ error: 'ContraseÃ±a actual incorrecta' });
        return;
      }

      // Actualizar contraseÃ±a
      const nuevaClaveHash = hashPasswordSHA256(claveNueva);
      const actualizado = await usuarioRepo.cambiarClave(idUsuario, nuevaClaveHash);

      if (actualizado) {
        res.json({ message: 'ContraseÃ±a actualizada exitosamente' });
      } else {
        res.status(500).json({ error: 'Error al actualizar contraseÃ±a' });
      }
    } catch (error: any) {
      console.error('Error al cambiar contraseÃ±a:', error);
      res.status(500).json({ error: 'Error al cambiar contraseÃ±a' });
    }
  }
);

// Actualizar solo la foto
router.put(
  '/mi-perfil/foto',
  [
    body('FotoPerfil')
      .notEmpty()
      .withMessage('La foto es requerida')
      .custom((value) => {
        if (value.startsWith('data:image')) {
          const sizeInBytes = (value.length * 3) / 4;
          const sizeInMB = sizeInBytes / (1024 * 1024);
          if (sizeInMB > 2) {
            throw new Error('La imagen no puede exceder 2MB');
          }
          return true;
        }
        throw new Error('Formato de imagen invÃ¡lido');
      })
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = req.user?.userId;
      if (!idUsuario) {
        res.status(401).json({ error: 'Usuario no autenticado' });
        return;
      }

      const { FotoPerfil } = req.body;
      const actualizado = await usuarioRepo.actualizarPerfil(idUsuario, { FotoPerfil });

      if (!actualizado) {
        res.status(404).json({ error: 'Usuario no encontrado' });
        return;
      }

      res.json({
        message: 'Foto de perfil actualizada exitosamente',
        FotoPerfil
      });
    } catch (error: any) {
      console.error('Error al actualizar foto:', error);
      res.status(500).json({ error: 'Error al actualizar foto' });
    }
  }
);

// Eliminar foto de perfil
router.delete('/mi-perfil/foto', async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = req.user?.userId;
    if (!idUsuario) {
      res.status(401).json({ error: 'Usuario no autenticado' });
      return;
    }

    const actualizado = await usuarioRepo.actualizarPerfil(idUsuario, { FotoPerfil: undefined });

    if (!actualizado) {
      res.status(404).json({ error: 'Usuario no encontrado' });
      return;
    }

    res.json({ message: 'Foto de perfil eliminada exitosamente' });
  } catch (error: any) {
    console.error('Error al eliminar foto:', error);
    res.status(500).json({ error: 'Error al eliminar foto' });
  }
});

// ==================== RUTAS ADMIN PARA GESTIÃ“N DE USUARIOS ====================

// Obtener perfil de otro usuario (solo admin)
router.get('/usuarios/:id', isAdmin, async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const idUsuario = parseInt(req.params.id);
    const usuario = await usuarioRepo.obtenerPorId(idUsuario);
    
    if (!usuario) {
      res.status(404).json({ error: 'Usuario no encontrado' });
      return;
    }

    const { ClaveHash, ...usuarioSinClave } = usuario;
    res.json(usuarioSinClave);
  } catch (error: any) {
    console.error('Error al obtener usuario:', error);
    res.status(500).json({ error: 'Error al obtener usuario' });
  }
});

// Actualizar perfil de otro usuario (solo admin)
router.put(
  '/usuarios/:id',
  isAdmin,
  [
    body('Nombre').optional().trim().isLength({ min: 1, max: 100 }),
    body('Apellido').optional().trim().isLength({ min: 1, max: 100 }),
    body('Email').optional().trim().isEmail(),
    body('Telefono').optional().trim().matches(/^[0-9\-\s\+\(\)]*$/),
    body('Direccion').optional().trim().isLength({ max: 255 }),
    body('FechaNacimiento').optional().isISO8601()
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = parseInt(req.params.id);
      const datos = req.body;
      
      const actualizado = await usuarioRepo.actualizarPerfil(idUsuario, datos);

      if (!actualizado) {
        res.status(404).json({ error: 'Usuario no encontrado' });
        return;
      }

      const usuarioActualizado = await usuarioRepo.obtenerPorId(idUsuario);
      
      if (usuarioActualizado) {
        const { ClaveHash, ...usuarioSinClave } = usuarioActualizado;
        res.json({
          message: 'Usuario actualizado exitosamente',
          usuario: usuarioSinClave
        });
      }
    } catch (error: any) {
      console.error('Error al actualizar usuario:', error);
      res.status(500).json({ error: 'Error al actualizar usuario' });
    }
  }
);

// Cambiar contraseÃ±a de otro usuario (solo admin)
router.put(
  '/usuarios/:id/cambiar-clave',
  isAdmin,
  [
    body('claveNueva')
      .isLength({ min: 6 })
      .withMessage('La contraseÃ±a debe tener al menos 6 caracteres')
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = parseInt(req.params.id);
      const { claveNueva } = req.body;

      const nuevaClaveHash = hashPasswordSHA256(claveNueva);
      const actualizado = await usuarioRepo.cambiarClave(idUsuario, nuevaClaveHash);

      if (actualizado) {
        res.json({ message: 'ContraseÃ±a actualizada exitosamente' });
      } else {
        res.status(404).json({ error: 'Usuario no encontrado' });
      }
    } catch (error: any) {
      console.error('Error al cambiar contraseÃ±a:', error);
      res.status(500).json({ error: 'Error al cambiar contraseÃ±a' });
    }
  }
);

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\producto.routes.ts
================================================================================
import { Router, Request, Response } from 'express';
import { ProductoRepository } from '../repositories/producto.repository';
import { authMiddleware, isAdmin } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';

const router = Router();
const productoRepo = new ProductoRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar productos
router.get('/', async (_req: Request, res: Response): Promise<void> => {
  try {
    const productos = await productoRepo.listar();
    res.json(productos);
  } catch (error: any) {
    console.error('Error al listar productos:', error);
    res.status(500).json({ error: 'Error al listar productos' });
  }
});

// Obtener productos con stock bajo
router.get('/stock-bajo', async (_req: Request, res: Response): Promise<void> => {
  try {
    const productos = await productoRepo.listar();
    const productosStockBajo = productos.filter(
      p => p.Stock <= p.StockMinimo && p.Estado
    );
    res.json(productosStockBajo);
  } catch (error: any) {
    console.error('Error al obtener productos con stock bajo:', error);
    res.status(500).json({ error: 'Error al obtener productos con stock bajo' });
  }
});

// Registrar producto (solo admin)
router.post(
  '/',
  isAdmin,
  [
    body('Nombre')
      .notEmpty().withMessage('Nombre es requerido')
      .isLength({ max: 100 }).withMessage('Nombre no puede exceder 100 caracteres'),
    body('IdCategoria')
      .isInt({ min: 1 }).withMessage('CategorÃ­a es requerida'),
    body('Precio')
      .isFloat({ min: 0.01 }).withMessage('Precio debe ser mayor a 0'),
    body('Stock')
      .isInt({ min: 0 }).withMessage('Stock debe ser un nÃºmero entero positivo'),
    body('StockMinimo')
      .isInt({ min: 0 }).withMessage('Stock mÃ­nimo debe ser un nÃºmero entero positivo')
  ],
  async (req: Request, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const producto = {
        ...req.body,
        Estado: true,
        FechaRegistro: new Date(),
        EsProductoFinal: req.body.EsProductoFinal !== undefined ? req.body.EsProductoFinal : true
      };

      const idProducto = await productoRepo.registrar(producto);
      res.status(201).json({
        message: 'Producto registrado exitosamente',
        idProducto
      });
    } catch (error: any) {
      console.error('Error al registrar producto:', error);
      res.status(500).json({ error: 'Error al registrar producto' });
    }
  }
);

// Editar producto (solo admin)
router.put(
  '/:id',
  isAdmin,
  [
    body('Nombre')
      .notEmpty().withMessage('Nombre es requerido')
      .isLength({ max: 100 }).withMessage('Nombre no puede exceder 100 caracteres'),
    body('IdCategoria')
      .isInt({ min: 1 }).withMessage('CategorÃ­a es requerida'),
    body('Precio')
      .isFloat({ min: 0.01 }).withMessage('Precio debe ser mayor a 0'),
    body('Stock')
      .isInt({ min: 0 }).withMessage('Stock debe ser un nÃºmero entero positivo'),
    body('StockMinimo')
      .isInt({ min: 0 }).withMessage('Stock mÃ­nimo debe ser un nÃºmero entero positivo')
  ],
  async (req: Request, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idProducto = parseInt(req.params.id);
      const producto = { ...req.body, IdProducto: idProducto };
      
      const resultado = await productoRepo.editar(producto);
      if (resultado) {
        res.json({ message: 'Producto actualizado exitosamente' });
      } else {
        res.status(404).json({ error: 'Producto no encontrado' });
      }
    } catch (error: any) {
      console.error('Error al editar producto:', error);
      res.status(500).json({ error: 'Error al editar producto' });
    }
  }
);

// Eliminar (desactivar) producto (solo admin)
router.delete('/:id', isAdmin, async (req: Request, res: Response): Promise<void> => {
  try {
    const idProducto = parseInt(req.params.id);
    const resultado = await productoRepo.eliminar(idProducto);
    if (resultado) {
      res.json({ message: 'Producto eliminado exitosamente' });
    } else {
      res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error: any) {
    console.error('Error al eliminar producto:', error);
    res.status(500).json({ error: 'Error al eliminar producto' });
  }
});

// Actualizar stock (usado internamente por ventas)
router.patch('/:id/stock', async (req: Request, res: Response): Promise<void> => {
  try {
    const idProducto = parseInt(req.params.id);
    const { cantidad } = req.body;

    if (!cantidad || cantidad <= 0) {
      res.status(400).json({ error: 'Cantidad invÃ¡lida' });
      return;
    }

    const resultado = await productoRepo.actualizarStock(idProducto, cantidad);
    if (resultado) {
      res.json({ message: 'Stock actualizado exitosamente' });
    } else {
      res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error: any) {
    console.error('Error al actualizar stock:', error);
    res.status(500).json({ error: 'Error al actualizar stock' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\reporte.routes.ts
================================================================================
import { Router, Request, Response } from 'express';
import { VentaRepository } from '../repositories/venta.repository';
import { ProductoRepository } from '../repositories/producto.repository';
import { authMiddleware } from '../middleware/auth.middleware';
import ExcelJS from 'exceljs';
import PDFDocument from 'pdfkit';

const router = Router();
const ventaRepo = new VentaRepository();
const productoRepo = new ProductoRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Obtener datos para reporte de ventas
router.get('/ventas', async (req: Request, res: Response): Promise<void> => {
  try {
    const { fechaInicio, fechaFin } = req.query;

    if (!fechaInicio || !fechaFin) {
      res.status(400).json({ error: 'Fechas de inicio y fin son requeridas' });
      return;
    }

    const inicio = new Date(fechaInicio as string);
    const fin = new Date(fechaFin as string);

    const ventas = await ventaRepo.listarPorFechas(inicio, fin);
    
    // Calcular totales
    const totalVentas = ventas.length;
    const montoTotal = ventas.reduce((sum, venta) => sum + Number(venta.Total), 0);
    const totalProductos = ventas.reduce((sum, venta) => sum + (venta.CantidadTotalProductos || 0), 0);

    res.json({
      ventas,
      estadisticas: {
        totalVentas: totalVentas || 0,
        montoTotal: isNaN(montoTotal) ? 0 : montoTotal,
        totalProductos: totalProductos || 0,
        promedioVenta: totalVentas > 0 ? (montoTotal / totalVentas) : 0
      }
    });
  } catch (error: any) {
    console.error('Error al obtener reporte de ventas:', error);
    res.status(500).json({ error: 'Error al obtener reporte de ventas' });
  }
});

// Obtener datos para reporte de productos
router.get('/productos', async (_req: Request, res: Response): Promise<void> => {
  try {
    const productos = await productoRepo.listar();
    
    // EstadÃ­sticas
    const totalProductos = productos.length;
    const productosActivos = productos.filter(p => p.Estado).length;
    const productosStockBajo = productos.filter(p => p.Stock <= p.StockMinimo && p.Estado).length;
    const valorInventario = productos
      .filter(p => p.Estado)
      .reduce((sum, p) => sum + (Number(p.Precio) * p.Stock), 0);

    res.json({
      productos,
      estadisticas: {
        totalProductos,
        productosActivos,
        productosStockBajo,
        valorInventario
      }
    });
  } catch (error: any) {
    console.error('Error al obtener reporte de productos:', error);
    res.status(500).json({ error: 'Error al obtener reporte de productos' });
  }
});

// Generar reporte de ventas en Excel
router.post('/ventas/excel', async (req: Request, res: Response): Promise<void> => {
  try {
    const { fechaInicio, fechaFin } = req.body;

    if (!fechaInicio || !fechaFin) {
      res.status(400).json({ error: 'Fechas de inicio y fin son requeridas' });
      return;
    }

    const inicio = new Date(fechaInicio);
    const fin = new Date(fechaFin);

    const ventas = await ventaRepo.listarPorFechas(inicio, fin);

    // Crear workbook
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Reporte de Ventas');

    // TÃ­tulo
    worksheet.mergeCells('A1:F1');
    worksheet.getCell('A1').value = 'REPORTE DE VENTAS';
    worksheet.getCell('A1').font = { size: 16, bold: true };
    worksheet.getCell('A1').alignment = { horizontal: 'center' };

    // InformaciÃ³n
    worksheet.getCell('A2').value = `PerÃ­odo: ${inicio.toLocaleDateString()} al ${fin.toLocaleDateString()}`;
    worksheet.getCell('A3').value = `Fecha de generaciÃ³n: ${new Date().toLocaleString()}`;

    // Encabezados
    worksheet.getRow(5).values = ['ID Venta', 'Fecha', 'Cajero', 'Total', 'MÃ©todo Pago', 'Estado'];
    worksheet.getRow(5).font = { bold: true };
    worksheet.getRow(5).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFD3D3D3' }
    };

    // Datos
    let row = 6;
    let totalGeneral = 0;
    
    ventas.forEach(venta => {
      worksheet.getRow(row).values = [
        venta.IdVenta,
        venta.FechaVenta ? new Date(venta.FechaVenta).toLocaleString() : '',
        venta.Usuario?.Nombre || 'N/A',
        Number(venta.Total),
        venta.MetodoPago,
        venta.Estado ? 'Activo' : 'Anulado'
      ];
      
      // Formato moneda
      worksheet.getCell(`D${row}`).numFmt = '$#,##0.00';
      
      totalGeneral += Number(venta.Total);
      row++;
    });

    // Total
    worksheet.getCell(`C${row + 1}`).value = 'TOTAL:';
    worksheet.getCell(`C${row + 1}`).font = { bold: true };
    worksheet.getCell(`D${row + 1}`).value = totalGeneral;
    worksheet.getCell(`D${row + 1}`).numFmt = '$#,##0.00';
    worksheet.getCell(`D${row + 1}`).font = { bold: true };

    // Ajustar columnas
    worksheet.columns.forEach(column => {
      column.width = 15;
    });

    // Enviar archivo
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename=Reporte_Ventas_${Date.now()}.xlsx`);

    await workbook.xlsx.write(res);
    res.end();
  } catch (error: any) {
    console.error('Error al generar Excel:', error);
    res.status(500).json({ error: 'Error al generar reporte Excel' });
  }
});

// Generar reporte de ventas en PDF
router.post('/ventas/pdf', async (req: Request, res: Response): Promise<void> => {
  try {
    const { fechaInicio, fechaFin } = req.body;

    if (!fechaInicio || !fechaFin) {
      res.status(400).json({ error: 'Fechas de inicio y fin son requeridas' });
      return;
    }

    const inicio = new Date(fechaInicio);
    const fin = new Date(fechaFin);

    const ventas = await ventaRepo.listarPorFechas(inicio, fin);

    // Crear PDF
    const doc = new PDFDocument({ margin: 50 });

    // Headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=Reporte_Ventas_${Date.now()}.pdf`);

    doc.pipe(res);

    // TÃ­tulo
    doc.fontSize(20).text('REPORTE DE VENTAS', { align: 'center' });
    doc.moveDown();

    // InformaciÃ³n
    doc.fontSize(10)
       .text(`PerÃ­odo: ${inicio.toLocaleDateString()} al ${fin.toLocaleDateString()}`)
       .text(`Fecha de generaciÃ³n: ${new Date().toLocaleString()}`)
       .moveDown();

    // Tabla
    let y = doc.y;
    const tableTop = y + 10;

    // Headers
    doc.fontSize(9).font('Helvetica-Bold');
    doc.text('ID', 50, tableTop);
    doc.text('Fecha', 90, tableTop);
    doc.text('Cajero', 190, tableTop);
    doc.text('Total', 290, tableTop);
    doc.text('MÃ©todo', 370, tableTop);
    doc.text('Estado', 470, tableTop);

    // LÃ­nea
    doc.moveTo(50, tableTop + 15)
       .lineTo(550, tableTop + 15)
       .stroke();

    // Datos
    doc.font('Helvetica');
    y = tableTop + 20;
    let totalGeneral = 0;

    ventas.forEach(venta => {
      if (y > 700) {
        doc.addPage();
        y = 50;
      }

      doc.text(venta.IdVenta?.toString() || '', 50, y);
      doc.text(venta.FechaVenta ? new Date(venta.FechaVenta).toLocaleDateString() : '', 90, y);
      doc.text(venta.Usuario?.Nombre || 'N/A', 190, y, { width: 90 });
      doc.text(`$${Number(venta.Total).toFixed(2)}`, 290, y);
      doc.text(venta.MetodoPago || '', 370, y);
      doc.text(venta.Estado ? 'Activo' : 'Anulado', 470, y);

      totalGeneral += Number(venta.Total);
      y += 20;
    });

    // Total
    doc.moveDown();
    doc.fontSize(12).font('Helvetica-Bold');
    doc.text(`TOTAL: $${totalGeneral.toFixed(2)}`, 290, y + 10);

    doc.end();
  } catch (error: any) {
    console.error('Error al generar PDF:', error);
    res.status(500).json({ error: 'Error al generar reporte PDF' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\usuario.routes.ts
================================================================================
import { Router, Request, Response } from 'express';
import { UsuarioRepository } from '../repositories/usuario.repository';
import { hashPasswordSHA256 } from '../utils/auth';
import { authMiddleware, isAdmin, AuthRequest } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';

const router = Router();
const usuarioRepo = new UsuarioRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar usuarios (solo admin)
router.get('/', isAdmin, async (_req: Request, res: Response): Promise<void> => {
  try {
    const usuarios = await usuarioRepo.listar();
    // Remover hashes de contraseÃ±as
    const usuariosSinClave = usuarios.map(u => {
      const { ClaveHash, ...usuario } = u;
      return usuario;
    });
    res.json(usuariosSinClave);
  } catch (error: any) {
    console.error('Error al listar usuarios:', error);
    res.status(500).json({ error: 'Error al listar usuarios' });
  }
});

// Registrar usuario (solo admin)
router.post(
  '/',
  isAdmin,
  [
    body('Nombre').notEmpty().withMessage('Nombre es requerido'),
    body('Apellido').notEmpty().withMessage('Apellido es requerido'),
    body('UsuarioNombre').notEmpty().withMessage('Usuario es requerido'),
    body('ClaveHash').isLength({ min: 6 }).withMessage('ContraseÃ±a debe tener al menos 6 caracteres'),
    body('IdRol').isInt().withMessage('Rol es requerido')
  ],
  async (req: Request, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const usuario = req.body;
      usuario.ClaveHash = hashPasswordSHA256(usuario.ClaveHash);
      usuario.Activo = true;
      usuario.FechaRegistro = new Date();

      const idUsuario = await usuarioRepo.registrar(usuario);
      res.status(201).json({
        message: 'Usuario registrado exitosamente',
        idUsuario
      });
    } catch (error: any) {
      console.error('Error al registrar usuario:', error);
      res.status(500).json({ error: 'Error al registrar usuario' });
    }
  }
);

// Editar usuario (solo admin)
router.put(
  '/:id',
  isAdmin,
  [
    body('Nombre').notEmpty().withMessage('Nombre es requerido'),
    body('Apellido').notEmpty().withMessage('Apellido es requerido'),
    body('UsuarioNombre').notEmpty().withMessage('Usuario es requerido'),
    body('IdRol').isInt().withMessage('Rol es requerido')
  ],
  async (req: Request, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = parseInt(req.params.id);
      const usuario = { ...req.body, IdUsuario: idUsuario };
      
      const resultado = await usuarioRepo.editar(usuario);
      if (resultado) {
        res.json({ message: 'Usuario actualizado exitosamente' });
      } else {
        res.status(404).json({ error: 'Usuario no encontrado' });
      }
    } catch (error: any) {
      console.error('Error al editar usuario:', error);
      res.status(500).json({ error: 'Error al editar usuario' });
    }
  }
);

// Cambiar contraseÃ±a (usuario propio o admin)
router.put(
  '/:id/cambiar-clave',
  [
    body('nuevaClave').isLength({ min: 6 }).withMessage('ContraseÃ±a debe tener al menos 6 caracteres')
  ],
  async (req: AuthRequest, res: Response): Promise<void> => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    try {
      const idUsuario = parseInt(req.params.id);
      const { nuevaClave } = req.body;

      // Verificar que sea admin o el mismo usuario
      if (req.user?.role !== 1 && req.user?.userId !== idUsuario) {
        res.status(403).json({ error: 'No autorizado' });
        return;
      }

      const nuevaClaveHash = hashPasswordSHA256(nuevaClave);
      const resultado = await usuarioRepo.cambiarClave(idUsuario, nuevaClaveHash);
      if (resultado) {
        res.json({ message: 'ContraseÃ±a actualizada exitosamente' });
      } else {
        res.status(404).json({ error: 'Usuario no encontrado' });
      }
    } catch (error: any) {
      console.error('Error al cambiar contraseÃ±a:', error);
      res.status(500).json({ error: 'Error al cambiar contraseÃ±a' });
    }
  }
);

// Eliminar (desactivar) usuario (solo admin)
router.delete('/:id', isAdmin, async (req: Request, res: Response): Promise<void> => {
  try {
    const idUsuario = parseInt(req.params.id);
    const resultado = await usuarioRepo.eliminar(idUsuario);
    if (resultado) {
      res.json({ message: 'Usuario eliminado exitosamente' });
    } else {
      res.status(404).json({ error: 'Usuario no encontrado' });
    }
  } catch (error: any) {
    console.error('Error al eliminar usuario:', error);
    res.status(500).json({ error: 'Error al eliminar usuario' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\routes\venta.routes.ts
================================================================================
import { Router, Request, Response } from 'express';
import { VentaRepository } from '../repositories/venta.repository';
import { authMiddleware, isAdmin, AuthRequest } from '../middleware/auth.middleware';
import { body, validationResult } from 'express-validator';
import { ticketService } from '../services/ticketService';

const router = Router();
const ventaRepo = new VentaRepository();

// Todas las rutas requieren autenticaciÃ³n
router.use(authMiddleware);

// Listar todas las ventas (solo admin)
router.get('/', isAdmin, async (req, res) => {
  try {
    const ventas = await ventaRepo.listar();
    res.json(ventas);
  } catch (error: any) {
    console.error('Error al listar ventas:', error);
    res.status(500).json({ error: 'Error al listar ventas' });
  }
});

// Listar ventas por usuario (cajero ve solo sus ventas)
router.get('/usuario/:idUsuario', async (req: AuthRequest, res) => {
  try {
    const idUsuario = parseInt(req.params.idUsuario);

    // Verificar que sea admin o el mismo usuario
    if (req.user?.role !== 1 && req.user?.userId !== idUsuario) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    const ventas = await ventaRepo.listarPorUsuario(idUsuario);
    res.json(ventas);
  } catch (error: any) {
    console.error('Error al listar ventas por usuario:', error);
    res.status(500).json({ error: 'Error al listar ventas por usuario' });
  }
});

// Listar ventas por rango de fechas
router.get('/fechas', async (req, res) => {
  try {
    const { fechaInicio, fechaFin } = req.query;

    if (!fechaInicio || !fechaFin) {
      return res.status(400).json({ error: 'Fechas de inicio y fin son requeridas' });
    }

    const inicio = new Date(fechaInicio as string);
    const fin = new Date(fechaFin as string);

    const ventas = await ventaRepo.listarPorFechas(inicio, fin);
    res.json(ventas);
  } catch (error: any) {
    console.error('Error al listar ventas por fechas:', error);
    res.status(500).json({ error: 'Error al listar ventas por fechas' });
  }
});

// Obtener detalle de una venta
router.get('/:id/detalle', async (req, res) => {
  try {
    const idVenta = parseInt(req.params.id);
    const detalle = await ventaRepo.obtenerDetalleVenta(idVenta);
    res.json(detalle);
  } catch (error: any) {
    console.error('Error al obtener detalle de venta:', error);
    res.status(500).json({ error: 'Error al obtener detalle de venta' });
  }
});

// Registrar venta
router.post(
  '/',
  [
    body('IdUsuario').isInt({ min: 1 }).withMessage('Usuario es requerido'),
    body('Total').isFloat({ min: 0.01 }).withMessage('Total debe ser mayor a 0'),
    body('MetodoPago').notEmpty().withMessage('MÃ©todo de pago es requerido'),
    body('DetallesVenta').isArray({ min: 1 }).withMessage('Debe incluir al menos un producto')
  ],
  async (req: AuthRequest, res: Response) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      // Verificar que el usuario estÃ© registrando su propia venta o sea admin
      const { IdUsuario, DetallesVenta } = req.body;
      
      if (req.user?.role !== 1 && req.user?.userId !== IdUsuario) {
        return res.status(403).json({ error: 'No puede registrar ventas para otro usuario' });
      }

      // Verificar stock de cada producto
      for (const detalle of DetallesVenta) {
        const stockVerificado = await ventaRepo.verificarStock(
          detalle.IdProducto,
          detalle.Cantidad
        );

        if (!stockVerificado.disponible) {
          return res.status(400).json({ error: stockVerificado.mensaje });
        }
      }

      // Registrar venta
      const venta = {
        ...req.body,
        Fecha: new Date(),
        FechaVenta: new Date(),
        Estado: true
      };

      const idVenta = await ventaRepo.registrarVenta(venta);
      res.status(201).json({ 
        message: 'Venta registrada exitosamente', 
        idVenta 
      });
    } catch (error: any) {
      console.error('Error al registrar venta:', error);
      res.status(500).json({ error: 'Error al registrar venta' });
    }
  }
);

// Verificar stock disponible
router.post('/verificar-stock', async (req, res) => {
  try {
    const { IdProducto, Cantidad } = req.body;

    if (!IdProducto || !Cantidad) {
      return res.status(400).json({ error: 'IdProducto y Cantidad son requeridos' });
    }

    const resultado = await ventaRepo.verificarStock(IdProducto, Cantidad);
    res.json(resultado);
  } catch (error: any) {
    console.error('Error al verificar stock:', error);
    res.status(500).json({ error: 'Error al verificar stock' });
  }
});

// Generar Ticket PDF
router.get('/:id/ticket', async (req: Request, res: Response): Promise<void> => {
  try {
    const idVenta = parseInt(req.params.id);

    // 1. Obtener la venta
    // Usamos listar y filtramos (soluciÃ³n rÃ¡pida compatible con tu repo actual)
    const ventas = await ventaRepo.listar(); 
    const venta = ventas.find(v => v.IdVenta === idVenta);

    if (!venta) {
      res.status(404).json({ error: 'Venta no encontrada' });
      return;
    }

    // 2. Obtener los detalles (productos)
    const detalles = await ventaRepo.obtenerDetalleVenta(idVenta);

    // 3. Configurar respuesta como PDF
    res.setHeader('Content-Type', 'application/pdf');
    // 'inline' hace que se abra en el navegador en lugar de descargar forzosamente
    res.setHeader('Content-Disposition', `inline; filename=Ticket_${idVenta}.pdf`);

    // 4. Generar
    ticketService.generarTicket(venta, detalles, res);

  } catch (error) {
    console.error('Error al generar ticket:', error);
    res.status(500).json({ error: 'Error al generar el ticket' });
  }
});

export default router;

================================================================================
ğŸ“‚ RUTA: backend\src\services\emailService.ts
================================================================================
// Backend/src/services/emailService.ts
import nodemailer, { Transporter } from 'nodemailer';
import { Notificacion } from '../models';

class EmailService {
  private transporter: Transporter | null = null;
  private enabled: boolean;
  private adminEmail: string;

  constructor() {
    this.enabled = process.env.EMAIL_ENABLED === 'true';
    this.adminEmail = process.env.EMAIL_ADMIN || 'admin@smartinventory.com';

    if (this.enabled) {
      this.initializeTransporter();
    }
  }

  private initializeTransporter() {
    try {
      this.transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST || 'smtp.gmail.com',
        port: parseInt(process.env.EMAIL_PORT || '587'),
        secure: process.env.EMAIL_SECURE === 'true',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASSWORD
        }
      });

      // Verificar conexiÃ³n
      this.transporter.verify((error) => {
        if (error) {
          console.error('âŒ Error al conectar con servidor de email:', error);
          this.enabled = false;
        } else {
          console.log('âœ… Servidor de email conectado correctamente');
        }
      });
    } catch (error) {
      console.error('âŒ Error al inicializar transporter de email:', error);
      this.enabled = false;
    }
  }

  // Enviar notificaciÃ³n por email
  async enviarNotificacion(notificacion: Notificacion): Promise<boolean> {
    if (!this.enabled || !this.transporter) {
      console.log('âš ï¸ Email deshabilitado o no configurado');
      return false;
    }

    // Solo enviar emails para notificaciones crÃ­ticas o de alta prioridad
    if (!['critica', 'alta'].includes(notificacion.Prioridad)) {
      return false;
    }

    try {
      const html = this.generarHTMLNotificacion(notificacion);

      await this.transporter.sendMail({
        from: process.env.EMAIL_FROM || 'Smart Inventory <noreply@smartinventory.com>',
        to: this.adminEmail,
        subject: `ğŸš¨ ${notificacion.Titulo}`,
        html
      });

      console.log(`âœ… Email enviado: ${notificacion.Titulo}`);
      return true;
    } catch (error) {
      console.error('âŒ Error al enviar email:', error);
      return false;
    }
  }

  // Generar HTML del email
  private generarHTMLNotificacion(notificacion: Notificacion): string {
    const prioridadColor = {
      critica: '#DC2626',
      alta: '#F97316',
      media: '#3B82F6',
      baja: '#6B7280'
    }[notificacion.Prioridad];

    const prioridadEmoji = {
      critica: 'ğŸš¨',
      alta: 'âš ï¸',
      media: 'â„¹ï¸',
      baja: 'ğŸ“Œ'
    }[notificacion.Prioridad];

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>NotificaciÃ³n - Smart Inventory</title>
      </head>
      <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f3f4f6;">
        <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f3f4f6; padding: 20px;">
          <tr>
            <td align="center">
              <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                
                <!-- Header -->
                <tr>
                  <td style="background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%); padding: 30px; text-align: center;">
                    <h1 style="margin: 0; color: #ffffff; font-size: 24px;">
                      ğŸ“¦ Smart Inventory
                    </h1>
                  </td>
                </tr>

                <!-- Prioridad Badge -->
                <tr>
                  <td style="padding: 20px 30px 0;">
                    <div style="display: inline-block; background-color: ${prioridadColor}; color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; text-transform: uppercase;">
                      ${prioridadEmoji} ${notificacion.Prioridad}
                    </div>
                  </td>
                </tr>

                <!-- TÃ­tulo -->
                <tr>
                  <td style="padding: 20px 30px 10px;">
                    <h2 style="margin: 0; color: #111827; font-size: 20px;">
                      ${notificacion.Titulo}
                    </h2>
                  </td>
                </tr>

                <!-- Mensaje -->
                <tr>
                  <td style="padding: 10px 30px 20px;">
                    <p style="margin: 0; color: #4b5563; font-size: 15px; line-height: 1.6;">
                      ${notificacion.Mensaje}
                    </p>
                  </td>
                </tr>

                ${notificacion.Producto ? `
                <!-- InformaciÃ³n del Producto -->
                <tr>
                  <td style="padding: 0 30px 20px;">
                    <table width="100%" cellpadding="10" style="background-color: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 4px;">
                      <tr>
                        <td>
                          <strong style="color: #92400e;">Producto:</strong>
                          <span style="color: #78350f;">${notificacion.Producto.Nombre}</span>
                        </td>
                      </tr>
                      <tr>
                        <td>
                          <strong style="color: #92400e;">Stock Actual:</strong>
                          <span style="color: #dc2626; font-weight: bold;">${notificacion.Producto.Stock}</span>
                        </td>
                      </tr>
                      <tr>
                        <td>
                          <strong style="color: #92400e;">Stock MÃ­nimo:</strong>
                          <span style="color: #78350f;">${notificacion.Producto.StockMinimo}</span>
                        </td>
                      </tr>
                    </table>
                  </td>
                </tr>
                ` : ''}

                <!-- Call to Action -->
                <tr>
                  <td style="padding: 20px 30px;">
                    <a href="http://localhost:5173/productos" style="display: inline-block; background-color: #8b5cf6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">
                      Ver en el Sistema
                    </a>
                  </td>
                </tr>

                <!-- Footer -->
                <tr>
                  <td style="padding: 20px 30px; background-color: #f9fafb; text-align: center; border-top: 1px solid #e5e7eb;">
                    <p style="margin: 0; color: #6b7280; font-size: 12px;">
                      Este es un mensaje automÃ¡tico de Smart Inventory<br>
                      <strong>Fecha:</strong> ${new Date().toLocaleString('es-SV')}
                    </p>
                  </td>
                </tr>

              </table>
            </td>
          </tr>
        </table>
      </body>
      </html>
    `;
  }

  // Enviar reporte diario de notificaciones crÃ­ticas
  async enviarResumenDiario(notificaciones: Notificacion[]): Promise<boolean> {
    if (!this.enabled || !this.transporter || notificaciones.length === 0) {
      return false;
    }

    try {
      const html = this.generarHTMLResumen(notificaciones);

      await this.transporter.sendMail({
        from: process.env.EMAIL_FROM || 'Smart Inventory <noreply@smartinventory.com>',
        to: this.adminEmail,
        subject: `ğŸ“Š Resumen Diario - ${notificaciones.length} Notificaciones Pendientes`,
        html
      });

      console.log('âœ… Resumen diario enviado');
      return true;
    } catch (error) {
      console.error('âŒ Error al enviar resumen diario:', error);
      return false;
    }
  }

  private generarHTMLResumen(notificaciones: Notificacion[]): string {
    const criticas = notificaciones.filter(n => n.Prioridad === 'critica').length;
    const altas = notificaciones.filter(n => n.Prioridad === 'alta').length;

    const listaNotificaciones = notificaciones.map(n => `
      <tr>
        <td style="padding: 10px; border-bottom: 1px solid #e5e7eb;">
          <strong>${n.Titulo}</strong><br>
          <span style="color: #6b7280; font-size: 13px;">${n.Mensaje}</span>
        </td>
      </tr>
    `).join('');

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Resumen Diario - Smart Inventory</title>
      </head>
      <body style="margin: 0; padding: 20px; font-family: Arial, sans-serif; background-color: #f3f4f6;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          
          <div style="background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%); padding: 30px; text-align: center;">
            <h1 style="margin: 0; color: white;">ğŸ“Š Resumen Diario</h1>
            <p style="margin: 10px 0 0; color: rgba(255,255,255,0.9);">${new Date().toLocaleDateString('es-SV', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>
          </div>

          <div style="padding: 30px;">
            <div style="display: flex; gap: 20px; margin-bottom: 30px;">
              <div style="flex: 1; padding: 15px; background-color: #fef2f2; border-left: 4px solid #dc2626; border-radius: 4px;">
                <div style="color: #7f1d1d; font-size: 24px; font-weight: bold;">${criticas}</div>
                <div style="color: #991b1b; font-size: 12px;">CrÃ­ticas</div>
              </div>
              <div style="flex: 1; padding: 15px; background-color: #fff7ed; border-left: 4px solid #f97316; border-radius: 4px;">
                <div style="color: #7c2d12; font-size: 24px; font-weight: bold;">${altas}</div>
                <div style="color: #9a3412; font-size: 12px;">Alta Prioridad</div>
              </div>
            </div>

            <h3 style="color: #111827; margin-bottom: 15px;">Notificaciones Pendientes</h3>
            <table width="100%" cellpadding="0" cellspacing="0">
              ${listaNotificaciones}
            </table>

            <div style="margin-top: 30px; text-align: center;">
              <a href="http://localhost:5173/productos" style="display: inline-block; background-color: #8b5cf6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">
                Ver en el Sistema
              </a>
            </div>
          </div>

          <div style="padding: 20px; background-color: #f9fafb; text-align: center; border-top: 1px solid #e5e7eb;">
            <p style="margin: 0; color: #6b7280; font-size: 12px;">
              Smart Inventory - Sistema de GestiÃ³n
            </p>
          </div>

        </div>
      </body>
      </html>
    `;
  }
}

export const emailService = new EmailService();

================================================================================
ğŸ“‚ RUTA: backend\src\services\ticketService.ts
================================================================================
// backend/src/services/ticketService.ts
import PDFDocument from 'pdfkit';
import { Venta, DetalleVenta } from '../models';

export const ticketService = {
  generarTicket: (venta: Venta, detalles: DetalleVenta[], res: any) => {
    // ConfiguraciÃ³n para papel tÃ©rmico de 58mm (aprox 165 puntos de ancho)
    const doc = new PDFDocument({
      size: [165, 1000], // Ancho fijo 58mm, largo dinÃ¡mico
      margins: { top: 10, bottom: 10, left: 5, right: 5 },
      autoFirstPage: false 
    });

    doc.pipe(res);
    doc.addPage();

    // --- ESTILOS ---
    const anchoUtil = 155;
    const fuenteNormal = 'Helvetica';
    const fuenteBold = 'Helvetica-Bold';

    // Helper para centrar texto
    const centrar = (texto: string, size: number = 7) => {
      doc.font(fuenteNormal).fontSize(size).text(texto, { align: 'center', width: anchoUtil });
    };

    // 1. ENCABEZADO
    doc.font(fuenteBold).fontSize(10)
       .text('SMART INVENTORY', { align: 'center', width: anchoUtil });
    
    doc.moveDown(0.2);
    centrar('Sucursal Principal');
    centrar('San Miguel, El Salvador');
    centrar('Tel: 7777-7777');
    doc.moveDown(0.5);

    // 2. DATOS DE LA VENTA
    centrar('--------------------------------');
    doc.font(fuenteNormal).fontSize(7);
    doc.text(`Ticket: #${venta.IdVenta}`);
    
    // Formatear fecha
    const fecha = venta.FechaVenta ? new Date(venta.FechaVenta) : new Date();
    doc.text(`Fecha: ${fecha.toLocaleDateString()} ${fecha.toLocaleTimeString()}`);
    doc.text(`Cajero: ${venta.Usuario?.Nombre || 'Cajero'}`);
    centrar('--------------------------------');
    doc.moveDown(0.5);

    // 3. DETALLE DE PRODUCTOS
    // Encabezados
    doc.font(fuenteBold).fontSize(6);
    const yHeader = doc.y;
    doc.text('CANT', 5, yHeader, { width: 20 });
    doc.text('PRODUCTO', 30, yHeader, { width: 85 });
    doc.text('TOTAL', 115, yHeader, { width: 40, align: 'right' });
    doc.moveDown(0.5);

    // Lista de Items
    doc.font(fuenteNormal);
    detalles.forEach(item => {
      const nombre = item.Producto?.Nombre || 'Producto';
      const subtotal = Number(item.Subtotal).toFixed(2);
      const yInicio = doc.y;

      // Columna Cantidad
      doc.text(item.Cantidad.toString(), 5, yInicio, { width: 20 });
      
      // Columna Nombre (multilÃ­nea si es largo)
      doc.text(nombre, 30, yInicio, { width: 85, align: 'left' });
      
      // Columna Total (alineado a la derecha)
      doc.text(`$${subtotal}`, 115, yInicio, { width: 40, align: 'right' });
      
      // Calcular nueva posiciÃ³n Y basada en la altura del nombre
      const alturaNombre = doc.heightOfString(nombre, { width: 85 });
      doc.y = yInicio + alturaNombre + 2; 
    });

    doc.moveDown(0.5);
    centrar('--------------------------------');

    // 4. TOTALES
    doc.font(fuenteBold).fontSize(8);
    const xLabel = 40;
    const xValue = 115;
    const wValue = 40;

    // Subtotal y Descuento (solo si aplica)
    if (venta.Descuento && Number(venta.Descuento) > 0) {
        doc.fontSize(7);
        doc.text('Subtotal:', xLabel, doc.y, { align: 'right', width: 70 });
        doc.moveUp();
        doc.text(`$${Number(venta.Subtotal).toFixed(2)}`, xValue, doc.y, { align: 'right', width: wValue });
        
        doc.text('Descuento:', xLabel, doc.y, { align: 'right', width: 70 });
        doc.moveUp();
        doc.text(`-$${Number(venta.Descuento).toFixed(2)}`, xValue, doc.y, { align: 'right', width: wValue });
        
        doc.moveDown(0.2);
    }

    // Total Final (Grande)
    doc.fontSize(10);
    doc.text('TOTAL:', xLabel, doc.y, { align: 'right', width: 70 });
    doc.moveUp();
    doc.text(`$${Number(venta.Total).toFixed(2)}`, xValue, doc.y, { align: 'right', width: wValue });
    
    // MÃ©todo de Pago
    doc.fontSize(7).font(fuenteNormal);
    doc.moveDown(0.5);
    doc.text(`Pago: ${venta.MetodoPago}`, { align: 'right', width: anchoUtil });

    // 5. PIE DE PÃGINA
    doc.moveDown(2);
    centrar('Â¡Gracias por su compra!');
    centrar('No se aceptan devoluciones');
    centrar('despuÃ©s de 3 dÃ­as.');
    
    // CÃ³digo de venta
    doc.moveDown(1);
    doc.fontSize(8).font('Courier').text(`*${venta.IdVenta}*`, { align: 'center' });

    doc.end();
  }
};

================================================================================
ğŸ“‚ RUTA: backend\src\utils\auth.ts
================================================================================
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

dotenv.config();

const JWT_SECRET = process.env.JWT_SECRET || 'your_super_secret_jwt_key_2025';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';

export const hashPasswordSHA256 = (password: string): string => {
  return crypto.createHash('sha256').update(password).digest('hex');
};

export const generateToken = (userId: number, username: string, role: number): string => {
  return jwt.sign(
    {
      userId,
      username,
      role
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN } as jwt.SignOptions
  );
};

export const verifyToken = (token: string): { userId: number; username: string; role: number } => {
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: number; username: string; role: number };
    return decoded;
  } catch (error) {
    throw new Error('Token invÃ¡lido o expirado');
  }
};

================================================================================
ğŸ“‚ RUTA: backend\src\utils\userAgent.ts
================================================================================
// backend/src/utils/userAgent.ts
import { Request } from 'express';

export interface ClientInfo {
  ip: string;
  navegador: string;
  dispositivo: string;
  sistemaOperativo: string;
}

export const extractClientInfo = (req: Request): ClientInfo => {
  const userAgent = req.headers['user-agent'] || 'Unknown';
  
  // Extraer IP
  const ip = (
    req.headers['x-forwarded-for'] as string ||
    req.headers['x-real-ip'] as string ||
    req.socket.remoteAddress ||
    'Unknown'
  ).split(',')[0].trim();

  // Detectar navegador
  let navegador = 'Unknown';
  if (userAgent.includes('Chrome') && !userAgent.includes('Edg')) navegador = 'Chrome';
  else if (userAgent.includes('Firefox')) navegador = 'Firefox';
  else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) navegador = 'Safari';
  else if (userAgent.includes('Edg')) navegador = 'Edge';
  else if (userAgent.includes('Opera') || userAgent.includes('OPR')) navegador = 'Opera';

  // Detectar dispositivo
  let dispositivo = 'Desktop';
  if (/mobile/i.test(userAgent)) dispositivo = 'Mobile';
  else if (/tablet|ipad/i.test(userAgent)) dispositivo = 'Tablet';

  // Detectar SO
  let sistemaOperativo = 'Unknown';
  if (userAgent.includes('Windows')) sistemaOperativo = 'Windows';
  else if (userAgent.includes('Mac OS')) sistemaOperativo = 'macOS';
  else if (userAgent.includes('Linux')) sistemaOperativo = 'Linux';
  else if (userAgent.includes('Android')) sistemaOperativo = 'Android';
  else if (userAgent.includes('iOS')) sistemaOperativo = 'iOS';

  return {
    ip,
    navegador,
    dispositivo,
    sistemaOperativo
  };
};

================================================================================
ğŸ“‚ RUTA: backend\src\workers\emailWorker.ts
================================================================================
// Backend/src/workers/emailWorker.ts
import { pool } from '../config/database';
import { emailService } from '../services/emailService';
import { Notificacion } from '../models';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

class EmailWorker {
  private isRunning: boolean = false;
  private intervalId: NodeJS.Timeout | null = null;

  // Iniciar worker (cada 1 minuto)
  start() {
    if (this.isRunning) {
      console.log('âš ï¸ Email worker ya estÃ¡ corriendo');
      return;
    }

    console.log('ğŸš€ Iniciando Email Worker...');
    this.isRunning = true;

    // Ejecutar inmediatamente
    this.procesarEmailsPendientes();

    // Ejecutar cada 1 minuto
    this.intervalId = setInterval(() => {
      this.procesarEmailsPendientes();
    }, 60000); // 60 segundos
  }

  // Detener worker
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      this.isRunning = false;
      console.log('ğŸ›‘ Email Worker detenido');
    }
  }

  // Procesar emails pendientes
  private async procesarEmailsPendientes() {
    try {
      // Obtener notificaciones que requieren email y no lo han enviado
      const [rows] = await pool.query<RowDataPacket[]>(`
        SELECT 
          n.IdNotificacion, n.Tipo, n.Titulo, n.Mensaje,
          n.IdProducto, n.Prioridad, n.Icono, n.Color,
          p.Nombre AS ProductoNombre,
          p.Stock AS ProductoStock,
          p.StockMinimo AS ProductoStockMinimo
        FROM Notificaciones n
        LEFT JOIN Productos p ON n.IdProducto = p.IdProducto
        WHERE n.EmailEnviado = FALSE
          AND n.Prioridad IN ('critica', 'alta')
          AND n.FechaCreacion > DATE_SUB(NOW(), INTERVAL 1 HOUR)
        ORDER BY 
          FIELD(n.Prioridad, 'critica', 'alta'),
          n.FechaCreacion ASC
        LIMIT 10
      `);

      if (rows.length === 0) {
        return;
      }

      console.log(`ğŸ“§ Procesando ${rows.length} notificaciones pendientes...`);

      for (const row of rows) {
        const notificacion: Notificacion = {
          IdNotificacion: row.IdNotificacion,
          Tipo: row.Tipo,
          Titulo: row.Titulo,
          Mensaje: row.Mensaje,
          IdProducto: row.IdProducto,
          Prioridad: row.Prioridad,
          Leida: false,
          Icono: row.Icono,
          Color: row.Color,
          Producto: row.ProductoNombre ? {
            Nombre: row.ProductoNombre,
            Stock: row.ProductoStock,
            StockMinimo: row.ProductoStockMinimo
          } : undefined
        };

        // Enviar email
        const enviado = await emailService.enviarNotificacion(notificacion);

        // Marcar como enviado
        if (enviado) {
          await pool.query<ResultSetHeader>(
            'UPDATE Notificaciones SET EmailEnviado = TRUE WHERE IdNotificacion = ?',
            [notificacion.IdNotificacion]
          );
        }

        // Delay de 1 segundo entre emails para evitar spam
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      console.log(`âœ… ${rows.length} emails procesados`);
    } catch (error) {
      console.error('âŒ Error al procesar emails:', error);
    }
  }

  // Enviar resumen diario (ejecutar manualmente o con cron)
  async enviarResumenDiario() {
    try {
      const [rows] = await pool.query<RowDataPacket[]>(`
        SELECT 
          IdNotificacion, Tipo, Titulo, Mensaje, Prioridad,
          FechaCreacion
        FROM Notificaciones
        WHERE Leida = FALSE
          AND Prioridad IN ('critica', 'alta')
        ORDER BY 
          FIELD(Prioridad, 'critica', 'alta'),
          FechaCreacion DESC
        LIMIT 20
      `);

      if (rows.length === 0) {
        console.log('âœ… No hay notificaciones pendientes para resumen diario');
        return;
      }

      const notificaciones: Notificacion[] = rows.map(row => ({
        IdNotificacion: row.IdNotificacion,
        Tipo: row.Tipo,
        Titulo: row.Titulo,
        Mensaje: row.Mensaje,
        Prioridad: row.Prioridad,
        Leida: false,
        FechaCreacion: row.FechaCreacion
      }));

      await emailService.enviarResumenDiario(notificaciones);
      console.log('âœ… Resumen diario enviado');
    } catch (error) {
      console.error('âŒ Error al enviar resumen diario:', error);
    }
  }
}

export const emailWorker = new EmailWorker();

================================================================================
ğŸ“‚ RUTA: backend\tsconfig.json
================================================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node", 
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

================================================================================
ğŸ“‚ RUTA: db_scripts\01_Schema_Principal.sql
================================================================================
-- Smart Inventory Database Script
USE Smart_Inventory;

-- ========================================
-- TABLAS
-- ========================================

-- Tabla Roles
CREATE TABLE IF NOT EXISTS Roles (
    IdRol INT AUTO_INCREMENT PRIMARY KEY,
    Rol VARCHAR(50) NOT NULL
);

-- Tabla Usuarios
CREATE TABLE IF NOT EXISTS Usuarios (
    IdUsuario INT AUTO_INCREMENT PRIMARY KEY,
    Nombre VARCHAR(100) NOT NULL,
    Apellido VARCHAR(100),
    Usuario VARCHAR(100) NOT NULL UNIQUE,
    ClaveHash VARCHAR(64),
    IdRol INT NOT NULL,
    Activo BIT DEFAULT 1,
    FechaRegistro DATETIME DEFAULT NOW(),
    FOREIGN KEY (IdRol) REFERENCES Roles(IdRol)
);

-- Tabla Categorias
CREATE TABLE IF NOT EXISTS Categorias (
    IdCategoria INT AUTO_INCREMENT PRIMARY KEY,
    Nombre VARCHAR(100) NOT NULL,
    Descripcion VARCHAR(255)
);

-- Tabla Productos
CREATE TABLE IF NOT EXISTS Productos (
    IdProducto INT AUTO_INCREMENT PRIMARY KEY,
    Nombre VARCHAR(100) NOT NULL,
    IdCategoria INT NOT NULL,
    Precio DECIMAL(10, 2) NOT NULL,
    Stock INT NOT NULL,
    Estado BIT DEFAULT 1,
    Descripcion VARCHAR(255),
    StockMinimo INT DEFAULT 0,
    FechaRegistro DATETIME DEFAULT NOW(),
    EsProductoFinal BIT DEFAULT 0,
    FOREIGN KEY (IdCategoria) REFERENCES Categorias(IdCategoria)
);

-- Tabla Ventas
CREATE TABLE IF NOT EXISTS Ventas (
    IdVenta INT AUTO_INCREMENT PRIMARY KEY,
    Fecha DATETIME DEFAULT NOW(),
    IdUsuario INT NOT NULL,
    Total DECIMAL(10, 2) NOT NULL,
    MetodoPago VARCHAR(50),
    Comentario VARCHAR(255),
    Estado VARCHAR(20) DEFAULT 'Activo',
    FechaVenta DATETIME DEFAULT NOW(),
    FOREIGN KEY (IdUsuario) REFERENCES Usuarios(IdUsuario)
);

-- Tabla DetalleVenta
CREATE TABLE IF NOT EXISTS DetalleVenta (
    IdDetalle INT AUTO_INCREMENT PRIMARY KEY,
    IdVenta INT NOT NULL,
    IdProducto INT NOT NULL,
    Cantidad INT NOT NULL,
    PrecioUnitario DECIMAL(10, 2) NOT NULL,
    Subtotal DECIMAL(18, 2),
    FOREIGN KEY (IdVenta) REFERENCES Ventas(IdVenta),
    FOREIGN KEY (IdProducto) REFERENCES Productos(IdProducto)
);

-- Tabla Reportes
CREATE TABLE IF NOT EXISTS Reportes (
    IdReporte INT AUTO_INCREMENT PRIMARY KEY,
    IdUsuario INT NOT NULL,
    TipoReporte VARCHAR(100),
    FechaGeneracion DATETIME DEFAULT NOW(),
    RutaArchivo VARCHAR(255),
    FOREIGN KEY (IdUsuario) REFERENCES Usuarios(IdUsuario)
);

-- Tabla HistorialSesiones
CREATE TABLE IF NOT EXISTS HistorialSesiones (
    IdSesion INT AUTO_INCREMENT PRIMARY KEY,
    IdUsuario INT NOT NULL,
    FechaHora DATETIME DEFAULT NOW(),
    DireccionIP VARCHAR(45),
    Navegador VARCHAR(200),
    Dispositivo VARCHAR(100),
    SistemaOperativo VARCHAR(100),
    Exitoso BOOLEAN DEFAULT TRUE,
    MotivoFallo VARCHAR(255),
    FOREIGN KEY (IdUsuario) REFERENCES Usuarios(IdUsuario),
    INDEX idx_usuario_fecha (IdUsuario, FechaHora DESC),
    INDEX idx_fecha (FechaHora DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ========================================
-- DATOS INICIALES
-- ========================================

-- Roles
INSERT INTO Roles (Rol) VALUES ('Admin');
INSERT INTO Roles (Rol) VALUES ('Cajero');

-- Usuarios (contraseÃ±as hasheadas con SHA256)
-- admin / admin123
INSERT INTO Usuarios (Nombre, Apellido, Usuario, ClaveHash, IdRol, Activo, FechaRegistro) 
VALUES ('Admin', 'System', 'admin', '240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9', 1, 1, NOW());

-- cajero / cajero123
INSERT INTO Usuarios (Nombre, Apellido, Usuario, ClaveHash, IdRol, Activo, FechaRegistro) 
VALUES ('Cajero', 'Principal', 'cajero', '1ed4353e845e2e537e017c0fac3a0d402d231809b7989e90da15191c1148a93f', 2, 1, NOW());

-- CategorÃ­as
INSERT INTO Categorias (Nombre, Descripcion) VALUES 
('Pasteles', 'Pasteles enteros y por rebanada'),
('Postres', 'Postres individuales y porciones'),
('Panes', 'Panes dulces y salados'),
('Bebidas', 'Bebidas frÃ­as y calientes'),
('Galletas', 'Galletas y productos horneados pequeÃ±os'),
('DecoraciÃ³n', 'ArtÃ­culos para decorar pasteles');

-- Productos
INSERT INTO Productos (Nombre, IdCategoria, Precio, Stock, Estado, Descripcion, StockMinimo, FechaRegistro, EsProductoFinal) VALUES
('Pastel de Chocolate', 1, 350.00, 5, 1, 'Pastel de chocolate de 1kg', 2, NOW(), 1),
('Pastel de Vainilla', 1, 40.00, 4, 1, 'Pastel de vainilla de 1kg', 2, NOW(), 1),
('Pastel Tres Leches', 1, 28.99, 4, 1, 'Pastel tres leches de 1kg', 2, NOW(), 1),
('Pastel Red Velvet', 1, 42.00, 2, 1, 'Pastel red velvet con queso crema', 2, NOW(), 1),
('Pastel Zanahoria', 1, 36.00, 4, 1, 'Pastel de zanahoria con nuez', 2, NOW(), 1),
('Flan Napolitano', 2, 5.00, 17, 1, 'Flan individual', 5, NOW(), 1),
('Gelatina', 2, 2.75, 30, 1, 'Gelatina de sabores', 10, NOW(), 1),
('TiramisÃº', 2, 4.30, 15, 1, 'TiramisÃº individual', 5, NOW(), 1),
('Cheesecake', 2, 6.00, 8, 1, 'Rebanada de cheesecake', 5, NOW(), 1),
('Brownie', 2, 7.50, 20, 1, 'Brownie de chocolate', 8, NOW(), 1),
('Concha', 3, 2.00, 50, 1, 'Pan dulce concha', 20, NOW(), 1),
('Cuernito', 3, 3.00, 40, 1, 'Cuernito de mantequilla', 15, NOW(), 1),
('Dona Glaseada', 3, 3.50, 35, 1, 'Dona con glaseado', 15, NOW(), 1),
('Pan de Elote', 3, 3.00, 20, 1, 'Rebanada de pan de elote', 10, NOW(), 1),
('Muffin', 3, 1.75, 30, 1, 'Muffin de arÃ¡ndano', 10, NOW(), 1),
('CafÃ© Americano', 4, 7.00, 100, 1, 'CafÃ© americano caliente', 20, NOW(), 1),
('CafÃ© Latte', 4, 7.00, 100, 1, 'CafÃ© latte', 20, NOW(), 1),
('Chocolate Caliente', 4, 6.50, 100, 1, 'Chocolate caliente', 20, NOW(), 1),
('Jugo Natural', 4, 6.75, 50, 1, 'Jugo de naranja', 15, NOW(), 1),
('Refresco', 4, 5.70, 80, 1, 'Refresco en lata', 30, NOW(), 1),
('Galletas Chocochips', 5, 2.40, 25, 1, 'Paquete de 6 galletas', 10, NOW(), 1),
('Galletas de Avena', 5, 3.99, 25, 1, 'Paquete de 6 galletas', 10, NOW(), 1),
('Macarrones', 5, 5.50, 20, 1, 'Caja de 4 macarrones', 8, NOW(), 1),
('Polvorones', 5, 2.00, 30, 1, 'Paquete de 6 polvorones', 10, NOW(), 1),
('Velas NÃºmeros', 6, 5.60, 50, 1, 'Velas para cumpleaÃ±os', 20, NOW(), 1),
('Velas Tradicionales', 6, 2.85, 60, 1, 'Paquete de 12 velas', 25, NOW(), 1),
('Topper Felicidades', 6, 9.00, 30, 1, 'DecoraciÃ³n para pastel', 10, NOW(), 1),
('Topper CumpleaÃ±os', 6, 25.00, 30, 1, 'DecoraciÃ³n para pastel', 10, NOW(), 1);

-- ========================================
-- STORED PROCEDURES
-- ========================================

DELIMITER $$

CREATE PROCEDURE sp_LoginUsuario(
    IN p_Usuario NVARCHAR(50),
    IN p_ClaveHash NVARCHAR(256)
)
BEGIN
    SELECT 
        u.IdUsuario, u.Nombre, u.Apellido, u.Usuario AS UsuarioNombre,
        u.ClaveHash, u.IdRol, u.Activo, u.FechaRegistro,
        r.IdRol AS Rol_IdRol, r.Rol AS Rol_Nombre
    FROM Usuarios u
    INNER JOIN Roles r ON r.IdRol = u.IdRol
    WHERE u.Usuario = p_Usuario
      AND u.ClaveHash = p_ClaveHash
      AND u.Activo = 1;
END$$

CREATE PROCEDURE sp_RegistrarUsuario(
    IN p_Nombre VARCHAR(100),
    IN p_Apellido VARCHAR(100),
    IN p_Usuario VARCHAR(100),
    IN p_Clave NVARCHAR(200),
    IN p_IdRol INT
)
BEGIN
    INSERT INTO Usuarios (Nombre, Apellido, Usuario, ClaveHash, IdRol)
    VALUES (
        p_Nombre,
        p_Apellido,
        p_Usuario,
        SHA2(p_Clave, 256),
        p_IdRol
    );
END$$

-- Stored Procedure para registrar sesiÃ³n

CREATE PROCEDURE sp_RegistrarSesion(
    IN p_IdUsuario INT,
    IN p_DireccionIP VARCHAR(45),
    IN p_Navegador VARCHAR(200),
    IN p_Dispositivo VARCHAR(100),
    IN p_SistemaOperativo VARCHAR(100),
    IN p_Exitoso BOOLEAN,
    IN p_MotivoFallo VARCHAR(255)
)
BEGIN
    INSERT INTO HistorialSesiones (
        IdUsuario, 
        DireccionIP, 
        Navegador, 
        Dispositivo, 
        SistemaOperativo,
        Exitoso, 
        MotivoFallo
    )
    VALUES (
        p_IdUsuario,
        p_DireccionIP,
        p_Navegador,
        p_Dispositivo,
        p_SistemaOperativo,
        p_Exitoso,
        p_MotivoFallo
    );
END$$

DELIMITER ;

================================================================================
ğŸ“‚ RUTA: db_scripts\02_migration_barcode.sql
================================================================================
-- migration_barcode.sql
-- Agregar campo de cÃ³digo de barras a la tabla Productos

USE Smart_Inventory;

-- Agregar columna CodigoBarras
ALTER TABLE Productos
ADD COLUMN CodigoBarras VARCHAR(50) NULL UNIQUE AFTER Nombre,
ADD INDEX idx_codigo_barras (CodigoBarras);

-- FunciÃ³n para generar cÃ³digo EAN-13 automÃ¡tico
DELIMITER $$

CREATE FUNCTION fn_GenerarCodigoBarras(p_IdProducto INT)
RETURNS VARCHAR(13)
DETERMINISTIC
BEGIN
    DECLARE v_Codigo VARCHAR(12);
    DECLARE v_CheckDigit INT;
    DECLARE v_Sum INT DEFAULT 0;
    DECLARE v_Pos INT DEFAULT 1;
    DECLARE v_Digit INT;
    
    -- Generar 12 dÃ­gitos base (prefijo 590 + IdProducto con padding)
    SET v_Codigo = LPAD(CONCAT('590', p_IdProducto), 12, '0');
    
    -- Calcular dÃ­gito verificador EAN-13
    WHILE v_Pos <= 12 DO
        SET v_Digit = CAST(SUBSTRING(v_Codigo, v_Pos, 1) AS UNSIGNED);
        
        IF v_Pos MOD 2 = 1 THEN
            SET v_Sum = v_Sum + v_Digit;
        ELSE
            SET v_Sum = v_Sum + (v_Digit * 3);
        END IF;
        
        SET v_Pos = v_Pos + 1;
    END WHILE;
    
    -- Calcular dÃ­gito de control
    SET v_CheckDigit = (10 - (v_Sum MOD 10)) MOD 10;
    
    -- Retornar cÃ³digo completo de 13 dÃ­gitos
    RETURN CONCAT(v_Codigo, v_CheckDigit);
END$$

DELIMITER ;

-- Procedimiento para actualizar productos existentes con cÃ³digos de barras
DELIMITER $$

CREATE PROCEDURE sp_GenerarCodigosBarrasProductos()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_IdProducto INT;
    DECLARE v_CodigoBarras VARCHAR(13);
    
    DECLARE cur CURSOR FOR 
        SELECT IdProducto 
        FROM Productos 
        WHERE CodigoBarras IS NULL;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO v_IdProducto;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Generar cÃ³digo de barras
        SET v_CodigoBarras = fn_GenerarCodigoBarras(v_IdProducto);
        
        -- Actualizar producto
        UPDATE Productos 
        SET CodigoBarras = v_CodigoBarras 
        WHERE IdProducto = v_IdProducto;
    END LOOP;
    
    CLOSE cur;
    
    SELECT CONCAT('âœ… ', COUNT(*), ' cÃ³digos de barras generados') AS Resultado
    FROM Productos 
    WHERE CodigoBarras IS NOT NULL;
END$$

DELIMITER ;

-- Ejecutar procedimiento para productos existentes
CALL sp_GenerarCodigosBarrasProductos();

-- Trigger para generar cÃ³digo automÃ¡ticamente en nuevos productos
DELIMITER $$

CREATE TRIGGER trg_GenerarCodigoBarras
BEFORE INSERT ON Productos
FOR EACH ROW
BEGIN
    IF NEW.CodigoBarras IS NULL OR NEW.CodigoBarras = '' THEN
        -- Obtener el prÃ³ximo ID que se asignarÃ¡
        SET @next_id = (SELECT AUTO_INCREMENT FROM information_schema.TABLES 
                        WHERE TABLE_SCHEMA = DATABASE() 
                        AND TABLE_NAME = 'Productos');
        
        -- Generar cÃ³digo de barras
        SET NEW.CodigoBarras = fn_GenerarCodigoBarras(@next_id);
    END IF;
END$$

DELIMITER ;

-- Verificar resultados
SELECT 
    IdProducto,
    Nombre,
    CodigoBarras,
    CASE 
        WHEN LENGTH(CodigoBarras) = 13 THEN 'âœ… VÃ¡lido'
        ELSE 'âŒ InvÃ¡lido'
    END AS Estado
FROM Productos
ORDER BY IdProducto;

-- InformaciÃ³n del sistema
SELECT 
    COUNT(*) AS TotalProductos,
    COUNT(CodigoBarras) AS ConCodigoBarras,
    COUNT(*) - COUNT(CodigoBarras) AS SinCodigoBarras
FROM Productos;

================================================================================
ğŸ“‚ RUTA: db_scripts\03_migration_notificaciones.sql
================================================================================
-- migration_notificaciones.sql
-- Sistema de Notificaciones para Smart Inventory

USE Smart_Inventory;

-- ========================================
-- TABLA DE NOTIFICACIONES
-- ========================================
CREATE TABLE IF NOT EXISTS Notificaciones (
    IdNotificacion INT AUTO_INCREMENT PRIMARY KEY,
    Tipo ENUM('stock_bajo', 'stock_critico', 'venta', 'sistema', 'alerta') NOT NULL DEFAULT 'alerta',
    Titulo VARCHAR(200) NOT NULL,
    Mensaje TEXT NOT NULL,
    IdProducto INT NULL,
    IdUsuario INT NULL,
    Prioridad ENUM('baja', 'media', 'alta', 'critica') NOT NULL DEFAULT 'media',
    Leida BOOLEAN DEFAULT FALSE,
    FechaCreacion DATETIME DEFAULT NOW(),
    FechaLeida DATETIME NULL,
    Icono VARCHAR(50) DEFAULT 'bell',
    Color VARCHAR(20) DEFAULT 'blue',
    Metadata JSON NULL,
    
    FOREIGN KEY (IdProducto) REFERENCES Productos(IdProducto) ON DELETE CASCADE,
    FOREIGN KEY (IdUsuario) REFERENCES Usuarios(IdUsuario) ON DELETE SET NULL,
    
    INDEX idx_leida (Leida),
    INDEX idx_fecha (FechaCreacion DESC),
    INDEX idx_tipo (Tipo),
    INDEX idx_prioridad (Prioridad),
    INDEX idx_usuario (IdUsuario)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ========================================
-- STORED PROCEDURE: Crear NotificaciÃ³n
-- ========================================
DELIMITER $$

CREATE PROCEDURE sp_CrearNotificacion(
    IN p_Tipo VARCHAR(20),
    IN p_Titulo VARCHAR(200),
    IN p_Mensaje TEXT,
    IN p_IdProducto INT,
    IN p_IdUsuario INT,
    IN p_Prioridad VARCHAR(10),
    IN p_Icono VARCHAR(50),
    IN p_Color VARCHAR(20)
)
BEGIN
    -- Evitar duplicados recientes (Ãºltimos 5 minutos)
    IF NOT EXISTS (
        SELECT 1 FROM Notificaciones
        WHERE Tipo = p_Tipo
          AND IdProducto = p_IdProducto
          AND Leida = FALSE
          AND FechaCreacion > DATE_SUB(NOW(), INTERVAL 5 MINUTE)
    ) THEN
        INSERT INTO Notificaciones (
            Tipo, Titulo, Mensaje, IdProducto, IdUsuario, 
            Prioridad, Icono, Color
        )
        VALUES (
            p_Tipo, p_Titulo, p_Mensaje, p_IdProducto, p_IdUsuario,
            p_Prioridad, p_Icono, p_Color
        );
    END IF;
END$$

-- ========================================
-- TRIGGER: Alerta de Stock Bajo
-- ========================================
CREATE TRIGGER trg_AlertaStockBajo
AFTER UPDATE ON Productos
FOR EACH ROW
BEGIN
    DECLARE v_Titulo VARCHAR(200);
    DECLARE v_Mensaje TEXT;
    DECLARE v_Prioridad VARCHAR(10);
    DECLARE v_Color VARCHAR(20);
    
    -- Solo si el stock disminuyÃ³ y estÃ¡ activo
    IF NEW.Estado = 1 AND NEW.Stock < OLD.Stock THEN
        
        -- Stock CRÃTICO (0 o negativo)
        IF NEW.Stock <= 0 THEN
            SET v_Titulo = CONCAT('âš ï¸ SIN STOCK: ', NEW.Nombre);
            SET v_Mensaje = CONCAT('El producto "', NEW.Nombre, '" se ha agotado. Stock actual: ', NEW.Stock);
            SET v_Prioridad = 'critica';
            SET v_Color = 'red';
            
            CALL sp_CrearNotificacion(
                'stock_critico', v_Titulo, v_Mensaje, NEW.IdProducto, 
                NULL, v_Prioridad, 'alert-triangle', v_Color
            );
        
        -- Stock BAJO (menor o igual al mÃ­nimo)
        ELSEIF NEW.Stock <= NEW.StockMinimo THEN
            SET v_Titulo = CONCAT('âš¡ Stock Bajo: ', NEW.Nombre);
            SET v_Mensaje = CONCAT(
                'El producto "', NEW.Nombre, 
                '" tiene stock bajo. Actual: ', NEW.Stock, 
                ' | MÃ­nimo: ', NEW.StockMinimo
            );
            SET v_Prioridad = 'alta';
            SET v_Color = 'orange';
            
            CALL sp_CrearNotificacion(
                'stock_bajo', v_Titulo, v_Mensaje, NEW.IdProducto, 
                NULL, v_Prioridad, 'package-x', v_Color
            );
        END IF;
    END IF;
END$$

DELIMITER ;

-- ========================================
-- GENERAR NOTIFICACIONES INICIALES
-- ========================================
-- Notificaciones para productos con stock bajo ACTUAL
INSERT INTO Notificaciones (Tipo, Titulo, Mensaje, IdProducto, Prioridad, Icono, Color)
SELECT 
    CASE 
        WHEN Stock <= 0 THEN 'stock_critico'
        ELSE 'stock_bajo'
    END AS Tipo,
    CONCAT(
        CASE 
            WHEN Stock <= 0 THEN 'âš ï¸ SIN STOCK: '
            ELSE 'âš¡ Stock Bajo: '
        END,
        Nombre
    ) AS Titulo,
    CONCAT(
        'El producto "', Nombre, 
        '" tiene stock ', 
        CASE WHEN Stock <= 0 THEN 'agotado' ELSE 'bajo' END,
        '. Actual: ', Stock, 
        ' | MÃ­nimo: ', StockMinimo
    ) AS Mensaje,
    IdProducto,
    CASE 
        WHEN Stock <= 0 THEN 'critica'
        ELSE 'alta'
    END AS Prioridad,
    CASE 
        WHEN Stock <= 0 THEN 'alert-triangle'
        ELSE 'package-x'
    END AS Icono,
    CASE 
        WHEN Stock <= 0 THEN 'red'
        ELSE 'orange'
    END AS Color
FROM Productos
WHERE Estado = 1 
  AND Stock <= StockMinimo;

-- ========================================
-- VISTAS ÃšTILES
-- ========================================
-- Vista de notificaciones no leÃ­das
CREATE OR REPLACE VIEW vw_NotificacionesNoLeidas AS
SELECT 
    n.IdNotificacion,
    n.Tipo,
    n.Titulo,
    n.Mensaje,
    n.Prioridad,
    n.Leida,
    n.FechaCreacion,
    n.Icono,
    n.Color,
    p.Nombre AS ProductoNombre,
    p.Stock AS ProductoStock,
    p.StockMinimo AS ProductoStockMinimo
FROM Notificaciones n
LEFT JOIN Productos p ON n.IdProducto = p.IdProducto
WHERE n.Leida = FALSE
ORDER BY 
    FIELD(n.Prioridad, 'critica', 'alta', 'media', 'baja'),
    n.FechaCreacion DESC;

-- ========================================
-- PROCEDIMIENTOS DE LIMPIEZA
-- ========================================
DELIMITER $$

-- Limpiar notificaciones antiguas (mÃ¡s de 30 dÃ­as)
CREATE PROCEDURE sp_LimpiarNotificacionesAntiguas()
BEGIN
    DELETE FROM Notificaciones
    WHERE Leida = TRUE
      AND FechaLeida < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    SELECT ROW_COUNT() AS NotificacionesEliminadas;
END$$

-- Marcar todas como leÃ­das
CREATE PROCEDURE sp_MarcarTodasLeidas(IN p_IdUsuario INT)
BEGIN
    UPDATE Notificaciones
    SET Leida = TRUE,
        FechaLeida = NOW()
    WHERE Leida = FALSE
      AND (IdUsuario IS NULL OR IdUsuario = p_IdUsuario);
    
    SELECT ROW_COUNT() AS NotificacionesMarcadas;
END$$

DELIMITER ;

-- ========================================
-- VERIFICACIÃ“N
-- ========================================
SELECT 
    COUNT(*) AS TotalNotificaciones,
    SUM(CASE WHEN Leida = FALSE THEN 1 ELSE 0 END) AS NoLeidas,
    SUM(CASE WHEN Prioridad = 'critica' THEN 1 ELSE 0 END) AS Criticas,
    SUM(CASE WHEN Prioridad = 'alta' THEN 1 ELSE 0 END) AS Altas
FROM Notificaciones;

SELECT * FROM vw_NotificacionesNoLeidas LIMIT 10;

================================================================================
ğŸ“‚ RUTA: db_scripts\04_migration_perfil.sql
================================================================================
-- Script para agregar campos de perfil a la tabla Usuarios
-- Ejecuta esto en tu base de datos Smart_Inventory

USE Smart_Inventory;

-- Agregar nuevos campos a la tabla Usuarios
ALTER TABLE Usuarios
ADD COLUMN FotoPerfil LONGTEXT NULL COMMENT 'Foto en base64 o URL',
ADD COLUMN Telefono VARCHAR(20) NULL,
ADD COLUMN Email VARCHAR(100) NULL,
ADD COLUMN Direccion VARCHAR(255) NULL,
ADD COLUMN FechaNacimiento DATE NULL;

-- Verificar que los campos se agregaron correctamente
DESCRIBE Usuarios;

-- (Opcional) Actualizar algunos usuarios de prueba con datos de ejemplo
UPDATE Usuarios 
SET 
    Email = 'admin@smartinventory.com',
    Telefono = '7777-7777'
WHERE Usuario = 'admin';

UPDATE Usuarios 
SET 
    Email = 'cajero@smartinventory.com',
    Telefono = '7888-8888'
WHERE Usuario = 'cajero';

-- Verificar los cambios
SELECT IdUsuario, Nombre, Apellido, Usuario, Email, Telefono, FotoPerfil 
FROM Usuarios;

================================================================================
ğŸ“‚ RUTA: db_scripts\05_update_triggers.sql
================================================================================
-- update_trigger_with_email.sql
-- Actualizar trigger para que el backend sepa que debe enviar email

USE Smart_Inventory;

-- Primero eliminamos el trigger existente
DROP TRIGGER IF EXISTS trg_AlertaStockBajo;

DELIMITER $$

-- Recrear trigger mejorado
CREATE TRIGGER trg_AlertaStockBajo
AFTER UPDATE ON Productos
FOR EACH ROW
BEGIN
    DECLARE v_Titulo VARCHAR(200);
    DECLARE v_Mensaje TEXT;
    DECLARE v_Prioridad VARCHAR(10);
    DECLARE v_Color VARCHAR(20);
    
    -- Solo si el stock disminuyÃ³ y estÃ¡ activo
    IF NEW.Estado = 1 AND NEW.Stock < OLD.Stock THEN
        
        -- Stock CRÃTICO (0 o negativo)
        IF NEW.Stock <= 0 THEN
            SET v_Titulo = CONCAT('âš ï¸ SIN STOCK: ', NEW.Nombre);
            SET v_Mensaje = CONCAT('El producto "', NEW.Nombre, '" se ha agotado completamente. Stock actual: ', NEW.Stock);
            SET v_Prioridad = 'critica';
            SET v_Color = 'red';
            
            -- Insertar notificaciÃ³n crÃ­tica
            INSERT INTO Notificaciones (
                Tipo, Titulo, Mensaje, IdProducto, 
                Prioridad, Icono, Color,
                Metadata
            ) VALUES (
                'stock_critico', v_Titulo, v_Mensaje, NEW.IdProducto,
                v_Prioridad, 'alert-triangle', v_Color,
                JSON_OBJECT('email_enviado', FALSE, 'requiere_email', TRUE)
            );
        
        -- Stock BAJO (menor o igual al mÃ­nimo)
        ELSEIF NEW.Stock <= NEW.StockMinimo THEN
            SET v_Titulo = CONCAT('âš¡ Stock Bajo: ', NEW.Nombre);
            SET v_Mensaje = CONCAT(
                'El producto "', NEW.Nombre, 
                '" tiene stock bajo. Actual: ', NEW.Stock, 
                ' | MÃ­nimo: ', NEW.StockMinimo
            );
            SET v_Prioridad = 'alta';
            SET v_Color = 'orange';
            
            -- Insertar notificaciÃ³n de stock bajo
            INSERT INTO Notificaciones (
                Tipo, Titulo, Mensaje, IdProducto, 
                Prioridad, Icono, Color,
                Metadata
            ) VALUES (
                'stock_bajo', v_Titulo, v_Mensaje, NEW.IdProducto,
                v_Prioridad, 'package-x', v_Color,
                JSON_OBJECT('email_enviado', FALSE, 'requiere_email', TRUE)
            );
        END IF;
    END IF;
END$$

DELIMITER ;

-- Agregar campo para tracking de emails enviados
ALTER TABLE Notificaciones 
ADD COLUMN EmailEnviado BOOLEAN DEFAULT FALSE AFTER Leida,
ADD INDEX idx_email_enviado (EmailEnviado);

-- Actualizar notificaciones existentes
UPDATE Notificaciones SET EmailEnviado = FALSE WHERE EmailEnviado IS NULL;

SELECT 'âœ… Trigger actualizado con soporte para emails' AS Status;

================================================================================
ğŸ“‚ RUTA: db_scripts\06_migration_descuentos.sql
================================================================================
-- migration_descuentos.sql
-- Sistema de Descuentos y Promociones para Smart Inventory

USE Smart_Inventory;

-- ========================================
-- TABLA DE DESCUENTOS
-- ========================================
CREATE TABLE IF NOT EXISTS Descuentos (
    IdDescuento INT AUTO_INCREMENT PRIMARY KEY,
    Nombre VARCHAR(100) NOT NULL,
    Descripcion TEXT,
    Tipo ENUM('porcentaje', 'monto_fijo', '2x1', '3x2', 'combo') NOT NULL,
    Valor DECIMAL(10,2) NULL COMMENT 'Porcentaje (0-100) o Monto fijo',
    
    -- Vigencia
    FechaInicio DATETIME NOT NULL,
    FechaFin DATETIME NOT NULL,
    Activo BOOLEAN DEFAULT TRUE,
    
    -- Condiciones de aplicaciÃ³n
    MontoMinimo DECIMAL(10,2) DEFAULT 0 COMMENT 'Monto mÃ­nimo de compra',
    IdCategoriaAplica INT NULL COMMENT 'Aplica solo a esta categorÃ­a',
    IdProductoAplica INT NULL COMMENT 'Aplica solo a este producto',
    
    -- Cupones
    CodigoCupon VARCHAR(50) UNIQUE NULL COMMENT 'CÃ³digo de cupÃ³n opcional',
    UsosMaximos INT DEFAULT NULL COMMENT 'NULL = ilimitado',
    UsosActuales INT DEFAULT 0,
    
    -- Combos (para tipo "combo")
    ProductosCombo JSON NULL COMMENT 'Array de {IdProducto, Cantidad, PrecioCombo}',
    
    -- Control
    CreadoPor INT NOT NULL,
    FechaCreacion DATETIME DEFAULT NOW(),
    
    FOREIGN KEY (IdCategoriaAplica) REFERENCES Categorias(IdCategoria) ON DELETE SET NULL,
    FOREIGN KEY (IdProductoAplica) REFERENCES Productos(IdProducto) ON DELETE SET NULL,
    FOREIGN KEY (CreadoPor) REFERENCES Usuarios(IdUsuario),
    
    INDEX idx_activo (Activo),
    INDEX idx_vigencia (FechaInicio, FechaFin),
    INDEX idx_codigo (CodigoCupon),
    INDEX idx_tipo (Tipo)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ========================================
-- TABLA DE DESCUENTOS APLICADOS EN VENTAS
-- ========================================
CREATE TABLE IF NOT EXISTS VentaDescuentos (
    IdVentaDescuento INT AUTO_INCREMENT PRIMARY KEY,
    IdVenta INT NOT NULL,
    IdDescuento INT NOT NULL,
    MontoDescuento DECIMAL(10,2) NOT NULL,
    TipoDescuento VARCHAR(50) NOT NULL,
    DescripcionDescuento VARCHAR(255),
    
    FOREIGN KEY (IdVenta) REFERENCES Ventas(IdVenta) ON DELETE CASCADE,
    FOREIGN KEY (IdDescuento) REFERENCES Descuentos(IdDescuento),
    
    INDEX idx_venta (IdVenta),
    INDEX idx_descuento (IdDescuento)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ========================================
-- STORED PROCEDURES
-- ========================================

DELIMITER $$

-- Obtener descuentos activos y vigentes
CREATE PROCEDURE sp_ObtenerDescuentosActivos()
BEGIN
    SELECT 
        d.*,
        c.Nombre AS CategoriaNombre,
        p.Nombre AS ProductoNombre,
        CASE 
            WHEN d.UsosMaximos IS NULL THEN 'Ilimitado'
            ELSE CONCAT(d.UsosActuales, '/', d.UsosMaximos)
        END AS UsosInfo
    FROM Descuentos d
    LEFT JOIN Categorias c ON d.IdCategoriaAplica = c.IdCategoria
    LEFT JOIN Productos p ON d.IdProductoAplica = p.IdProducto
    WHERE d.Activo = TRUE
      AND NOW() BETWEEN d.FechaInicio AND d.FechaFin
      AND (d.UsosMaximos IS NULL OR d.UsosActuales < d.UsosMaximos)
    ORDER BY d.FechaCreacion DESC;
END$$

-- Validar cupÃ³n
CREATE PROCEDURE sp_ValidarCupon(
    IN p_Codigo VARCHAR(50),
    IN p_MontoCompra DECIMAL(10,2)
)
BEGIN
    SELECT 
        d.*,
        CASE 
            WHEN d.Activo = FALSE THEN 'CupÃ³n inactivo'
            WHEN NOW() < d.FechaInicio THEN 'CupÃ³n aÃºn no vigente'
            WHEN NOW() > d.FechaFin THEN 'CupÃ³n expirado'
            WHEN d.UsosMaximos IS NOT NULL AND d.UsosActuales >= d.UsosMaximos THEN 'CupÃ³n agotado'
            WHEN p_MontoCompra < d.MontoMinimo THEN CONCAT('Compra mÃ­nima: $', d.MontoMinimo)
            ELSE 'VALIDO'
        END AS EstadoValidacion
    FROM Descuentos d
    WHERE d.CodigoCupon = p_Codigo;
END$$

-- Registrar uso de descuento
CREATE PROCEDURE sp_RegistrarUsoDescuento(
    IN p_IdDescuento INT,
    IN p_IdVenta INT,
    IN p_MontoDescuento DECIMAL(10,2)
)
BEGIN
    -- Incrementar contador de usos
    UPDATE Descuentos 
    SET UsosActuales = UsosActuales + 1
    WHERE IdDescuento = p_IdDescuento;
    
    -- Registrar en VentaDescuentos
    INSERT INTO VentaDescuentos (IdVenta, IdDescuento, MontoDescuento, TipoDescuento, DescripcionDescuento)
    SELECT 
        p_IdVenta,
        p_IdDescuento,
        p_MontoDescuento,
        d.Tipo,
        d.Nombre
    FROM Descuentos d
    WHERE d.IdDescuento = p_IdDescuento;
END$$

-- Calcular descuento aplicable
CREATE PROCEDURE sp_CalcularDescuento(
    IN p_IdDescuento INT,
    IN p_Subtotal DECIMAL(10,2),
    IN p_IdProducto INT,
    IN p_Cantidad INT
)
BEGIN
    DECLARE v_MontoDescuento DECIMAL(10,2) DEFAULT 0;
    DECLARE v_Tipo VARCHAR(20);
    DECLARE v_Valor DECIMAL(10,2);
    DECLARE v_ProductoAplica INT;
    
    SELECT Tipo, Valor, IdProductoAplica 
    INTO v_Tipo, v_Valor, v_ProductoAplica
    FROM Descuentos
    WHERE IdDescuento = p_IdDescuento;
    
    -- Calcular segÃºn tipo
    IF v_Tipo = 'porcentaje' THEN
        SET v_MontoDescuento = (p_Subtotal * v_Valor) / 100;
        
    ELSEIF v_Tipo = 'monto_fijo' THEN
        SET v_MontoDescuento = v_Valor;
        
    ELSEIF v_Tipo = '2x1' AND v_ProductoAplica = p_IdProducto THEN
        -- Descuento del 50% si compra 2 o mÃ¡s
        IF p_Cantidad >= 2 THEN
            SET v_MontoDescuento = p_Subtotal * 0.5;
        END IF;
        
    ELSEIF v_Tipo = '3x2' AND v_ProductoAplica = p_IdProducto THEN
        -- Por cada 3, el 3ro es gratis (33.33% descuento)
        IF p_Cantidad >= 3 THEN
            SET v_MontoDescuento = (p_Subtotal / p_Cantidad) * FLOOR(p_Cantidad / 3);
        END IF;
    END IF;
    
    -- No puede ser mayor al subtotal
    IF v_MontoDescuento > p_Subtotal THEN
        SET v_MontoDescuento = p_Subtotal;
    END IF;
    
    SELECT v_MontoDescuento AS MontoDescuento;
END$$

DELIMITER ;

-- ========================================
-- DATOS DE EJEMPLO
-- ========================================

-- Descuento por porcentaje (10% en todo)
INSERT INTO Descuentos (
    Nombre, Descripcion, Tipo, Valor,
    FechaInicio, FechaFin, MontoMinimo, CreadoPor
) VALUES (
    'Descuento 10% General',
    'Descuento del 10% en toda la tienda',
    'porcentaje',
    10.00,
    NOW(),
    DATE_ADD(NOW(), INTERVAL 30 DAY),
    0.00,
    1
);

-- CupÃ³n de $5 dÃ³lares
INSERT INTO Descuentos (
    Nombre, Descripcion, Tipo, Valor,
    FechaInicio, FechaFin, MontoMinimo,
    CodigoCupon, UsosMaximos, CreadoPor
) VALUES (
    'CupÃ³n $5 OFF',
    'CupÃ³n de $5 dÃ³lares de descuento',
    'monto_fijo',
    5.00,
    NOW(),
    DATE_ADD(NOW(), INTERVAL 60 DAY),
    20.00,
    'AHORRA5',
    100,
    1
);

-- PromociÃ³n 2x1 en Brownies (IdProducto = 10)
INSERT INTO Descuentos (
    Nombre, Descripcion, Tipo,
    FechaInicio, FechaFin,
    IdProductoAplica, CreadoPor
) VALUES (
    '2x1 en Brownies',
    'Lleva 2 brownies al precio de 1',
    '2x1',
    NOW(),
    DATE_ADD(NOW(), INTERVAL 15 DAY),
    10, -- IdProducto del Brownie
    1
);

-- Descuento de cumpleaÃ±os (20% cupÃ³n Ãºnico)
INSERT INTO Descuentos (
    Nombre, Descripcion, Tipo, Valor,
    FechaInicio, FechaFin,
    CodigoCupon, UsosMaximos, CreadoPor
) VALUES (
    'CupÃ³n de CumpleaÃ±os',
    '20% de descuento en tu cumpleaÃ±os',
    'porcentaje',
    20.00,
    NOW(),
    DATE_ADD(NOW(), INTERVAL 365 DAY),
    'FELIZ2025',
    1,
    1
);

-- ========================================
-- VISTAS ÃšTILES
-- ========================================

-- Vista de descuentos activos con estadÃ­sticas
CREATE OR REPLACE VIEW vw_DescuentosActivos AS
SELECT 
    d.IdDescuento,
    d.Nombre,
    d.Descripcion,
    d.Tipo,
    d.Valor,
    d.FechaInicio,
    d.FechaFin,
    d.MontoMinimo,
    d.CodigoCupon,
    d.UsosMaximos,
    d.UsosActuales,
    CASE 
        WHEN d.UsosMaximos IS NULL THEN 'Ilimitado'
        ELSE CONCAT(ROUND((d.UsosActuales / d.UsosMaximos) * 100, 1), '%')
    END AS PorcentajeUso,
    c.Nombre AS CategoriaNombre,
    p.Nombre AS ProductoNombre,
    DATEDIFF(d.FechaFin, NOW()) AS DiasRestantes
FROM Descuentos d
LEFT JOIN Categorias c ON d.IdCategoriaAplica = c.IdCategoria
LEFT JOIN Productos p ON d.IdProductoAplica = p.IdProducto
WHERE d.Activo = TRUE
  AND NOW() BETWEEN d.FechaInicio AND d.FechaFin;

-- Vista de descuentos usados en ventas
CREATE OR REPLACE VIEW vw_DescuentosUsados AS
SELECT 
    vd.IdVentaDescuento,
    vd.IdVenta,
    v.FechaVenta,
    v.IdUsuario,
    CONCAT(u.Nombre, ' ', u.Apellido) AS Usuario,
    d.Nombre AS NombreDescuento,
    d.Tipo AS TipoDescuento,
    vd.MontoDescuento,
    v.Total AS TotalVenta
FROM VentaDescuentos vd
INNER JOIN Ventas v ON vd.IdVenta = v.IdVenta
INNER JOIN Descuentos d ON vd.IdDescuento = d.IdDescuento
INNER JOIN Usuarios u ON v.IdUsuario = u.IdUsuario
ORDER BY v.FechaVenta DESC;

-- ========================================
-- VERIFICACIÃ“N
-- ========================================

SELECT 'TABLAS CREADAS:' AS Status;
SHOW TABLES LIKE '%Descuento%';

SELECT 'DESCUENTOS DE EJEMPLO:' AS Status;
SELECT * FROM vw_DescuentosActivos;

SELECT 'âœ… MigraciÃ³n de Descuentos completada exitosamente' AS Status;

